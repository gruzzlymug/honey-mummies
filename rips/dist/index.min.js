/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = (function () {
  Boid.prototype.numBoids = 0;
  Boid.prototype.pos = [];
  Boid.prototype.vel = [];
  Boid.prototype.neighbors = [];
  Boid.prototype.centroid = [];

  function Boid(pos, vel) {
    this.id = Boid.prototype.numBoids++;
    Boid.prototype.pos[this.id] = pos;
    Boid.prototype.vel[this.id] = vel;
    Boid.prototype.neighbors[this.id] = [];
  }

  Boid.prototype.constructor = Boid

  Boid.prototype.separate = function () {
    var neighbors = Boid.prototype.neighbors[this.id]
    var numNeighbors = neighbors.length;
    var av = [0, 0];
    var bp = Boid.prototype.pos[this.id];
    var threshold = 100*100;
    for (var i = 0; i < numNeighbors; ++i) {
      var nid = neighbors[i];
      var np = Boid.prototype.pos[nid];

      var d = [0, 0];
      d[0] = bp[0] - np[0];
      d[1] = bp[1] - np[1];
      var ds = d[0]*d[0] + d[1]*d[1];
      if (ds < threshold) {
        // NOTE add factor to prevent divide by 0
        ds += 0.1;
        var factor = threshold / ds;
        av[0] += d[0] * factor;
        av[1] += d[1] * factor;
      }
    }
    av = normalize(av);

    return av;
  }

  Boid.prototype.cohere = function () {
    var cv = [0, 0];
    if (Boid.prototype.neighbors[this.id].length === 0) {
      return cv;
    }

    goal = Boid.prototype.centroid[this.id];
    var bp = Boid.prototype.pos[this.id];
    cv[0] = goal[0] - bp[0];
    cv[1] = goal[1] - bp[1];
    return cv;
  }

  function clamper() {

  }

  Boid.prototype.update = function (dt) {
    // velocity modifiers
    var sv = this.separate();
    var sf = 0.0;

    var cv = this.cohere();
    // let dist2 = dot(cv, cv);
    // if (dist2 < 4 || dist2 > 120) {
    //   cv = [0, 0];
    // }
    var cf = 0.0;

    //----
    let bvc = 0.99999999;
    var bv = Boid.prototype.vel[this.id];

    var vm = [0, 0];
    vm[0] = sf*sv[0] + cf*cv[0] + bvc*bv[0];
    vm[1] = sf*sv[1] + cf*cv[1] + bvc*bv[1];

    let vl = Math.sqrt(dot(vm, vm));
    if (vl > 4) {
      vm = normalize(vm);
      vm[0] *= 4;
      vm[1] *= 4;
    }

    Boid.prototype.vel[this.id] = vm;
  }

  Boid.prototype.move = function (dt) {
    let vc = 1;
    Boid.prototype.pos[this.id][0] += (vc * Boid.prototype.vel[this.id][0]);
    Boid.prototype.pos[this.id][1] += (vc * Boid.prototype.vel[this.id][1]);

    // keep boid within limits
    var width = 200; //context.canvas.width - 1;
    var height = 200; //context.canvas.height - 1;

    var bx = Boid.prototype.pos[this.id][0];
    if (bx >= width) {
      Boid.prototype.pos[this.id][0] = 0; // bx - width;
    } else if (bx < 0) {
      Boid.prototype.pos[this.id][0] = width; // bx + width;
    }

    var by = Boid.prototype.pos[this.id][1];
    if (by >= height) {
      Boid.prototype.pos[this.id][1] = 0; // by - height;
    } else if (by < 0) {
      Boid.prototype.pos[this.id][1] = height; // by + height;
    }
  }

  Boid.prototype.draw = function (context) {
    this.ctx = context;

    var x = Boid.prototype.pos[this.id][0];
    var y = Boid.prototype.pos[this.id][1];

    context.beginPath();
    context.fillStyle = "blue";
    if (this.id != 0) {
      context.fillStyle = "yellow";
    }
    context.arc(x, y, 4, 0, 2*Math.PI, false);
    context.fill();
  }

  function sayIt() {
    console.log("HEEBEE JEEBEE");
  }

  Boid.prototype.blah = function () {
    sayIt();
  }

  return Boid;
})();


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mildo__ = __webpack_require__(5);
__webpack_require__(2);
// import Boid from './Boid'
var Grid = __webpack_require__(3);
var Flock = __webpack_require__(4);


//--[ step ]--------------------------------------------------------------
function step(timestamp) {
  let frameTimeMs = timestamp - last;
  last = timestamp;
  // console.log(frameTimeMs);

  // frames per second
  let elapsedTime = (timestamp - startTime) / 1000,
  result = Math.floor((frame / elapsedTime));
  if (elapsedTime > 1) {
    startTime = timestamp;
    frame = 0;
  }
  if (frame % 10 == 0) {
    let fpsText = result.toString();
    // console.log(fpsText);
  }
  ++frame;

  context.fillStyle = "black";
  context.fillRect(0, 0, canvas.width, canvas.height);

  if (frame % 3 === 0) {
    f.update(timestamp);
  }
  f.spawn(0);
  f.debugDraw(context);
  f.draw(context);

  window.requestAnimationFrame(step);
}

//------------------------------------------------------------------------
var last = performance.now();
var startTime = last;
var frame = 0;

let m = new __WEBPACK_IMPORTED_MODULE_0__mildo__["a" /* default */]();

let ww = window.innerWidth;
let wh = window.innerHeight;
var canvas = document.getElementById('field');
var context = canvas.getContext('2d');
context.canvas.width = ww;
context.canvas.height = wh;

let g = new Grid(ww, wh, 100);
let f = new Flock(g);
f.createBoids(100);
//f.createSource(ww / 2, wh / 2);
f.createSource(25, 25);

window.requestAnimationFrame(step);


/***/ }),
/* 2 */
/***/ (function(module, exports) {

//
// Simulation Math Utilities
//
if (module === undefined) {
  var module = {};
}

module.exports = (function () {
  this.nearlyZero = 0.0001;

  this.normalize = function (v) {
    let lv = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
    if (Math.abs(lv) > nearlyZero) {
      v[0] /= lv;
      v[1] /= lv;
    }
    return v;
  }

  this.dot = function(v1, v2) {
    return v1[0]*v2[0] + v1[1]*v2[1]
  }

  this.buildRotationMatrix = function(degrees) {
    var radians = degrees * Math.PI / 180.0;
    var matrix = [
      [Math.cos(radians), -Math.sin(radians)],
      [Math.sin(radians), Math.cos(radians)],
    ];
    return matrix;
  }

  this.rotate = function(v, m) {
    var x = m[0][0]*v[0] + m[0][1]*v[1]
    var y = m[1][0]*v[0] + m[1][1]*v[1]
    return [x, y];
  }

  this.randomInRange = function(min, max, wantInt) {
    var max = (max === 0 || max) ? max : 1,
        min = min || 0,
        gen = min + (max - min) * Math.random();

    return (wantInt) ? Math.round(gen) : gen;
  }

  return {
    // normalize: normalize,
    dot: dot,
    buildRotationMatrix: buildRotationMatrix,
    rotate: rotate,
    randomInRange: randomInRange
  };
})();


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var Boid = __webpack_require__(0);

module.exports = (function () {
  // move to reset fn?
  Grid.prototype.width = 0;
  Grid.prototype.height = 0;
  Grid.prototype.cx = 0;
  Grid.prototype.cy = 0;
  Grid.prototype.minCellDim = 0;
  Grid.prototype.field = [];

  function Grid(width, height, minCellDim) {
    // x
    Grid.prototype.width = width;
    Grid.prototype.cx = Math.ceil(width / minCellDim);

    // y
    Grid.prototype.height = height;
    Grid.prototype.cy = Math.ceil(height / minCellDim);

    Grid.prototype.minCellDim = minCellDim;

    for (var x = 0; x < Grid.prototype.cx; ++x) {
      Grid.prototype.field[x] = []
      for (var y = 0; y < Grid.prototype.cy; ++y) {
        Grid.prototype.field[x].push([]);
      }
    }

    var endit = 0;
  }

  Grid.prototype.constructor = Grid;

  Grid.prototype.add = function(positions) {
    // clear the grid
    for (var x = 0; x < Grid.prototype.field.length; ++x) {
      for (var y = 0; y < Grid.prototype.field[0].length; ++y) {
        Grid.prototype.field[x][y] = []
      }
    }

    // do the adding
    var numPositions = positions.length;
    for (var idxPos = 0; idxPos < numPositions; ++idxPos) {
      var bp = positions[idxPos];
      var xc = Math.floor(bp[0] / Grid.prototype.minCellDim);
      var yc = Math.floor(bp[1] / Grid.prototype.minCellDim);
      if (Grid.prototype.field[xc] === undefined) {
        var break_here = true;
      }
      Grid.prototype.field[xc][yc].push(idxPos);
      // color boids based on position
      // Boid.prototype.hue[idxPos] = ((yc + xc) % 2) == 0 ? "blue" : "green"
    }

    // save the positions for the queries
    Grid.prototype.positions = positions;
  }

  Grid.prototype.query = function(mx, my) {
    var xc = Math.floor(mx / Grid.prototype.minCellDim);
    var yc = Math.floor(my / Grid.prototype.minCellDim);

    var selectedID = null;
    var minToBoidSqr = Grid.prototype.minCellDim * Grid.prototype.minCellDim;
    var candidates = Grid.prototype.field[xc][yc];
    var numCandidates = candidates.length;
    for (var idxCandidate = 0; idxCandidate < numCandidates; ++idxCandidate) {
      var candidateID = candidates[idxCandidate];
      var pos = Grid.prototype.positions[candidateID];
      var dx = pos[0] - mx;
      var dy = pos[1] - my;
      var toBoidSqr = dx*dx + dy*dy;
      if (toBoidSqr < 121 && toBoidSqr < minToBoidSqr) {
        selectedID = candidateID;
        minToBoidSqr = toBoidSqr;
      }
    }

    return selectedID;
  }

  Grid.prototype.findNeighbors = function(threshold, maxNeighbors) {
    var scaleFactor = 1000;
    var numBoids = Boid.prototype.numBoids;

    for (var idxBoid = 0; idxBoid < numBoids; ++idxBoid) {
      var bp = Boid.prototype.pos[idxBoid];
      var qx = bp[0];
      var qy = bp[1];

      var x0 = Math.floor((qx - threshold) / Grid.prototype.minCellDim);
      x0 = Math.max(0, x0);
      var x1 = Math.floor((qx + threshold) / Grid.prototype.minCellDim);
      x1 = Math.min(Grid.prototype.field.length - 1, x1);
      var y0 = Math.floor((qy - threshold) / Grid.prototype.minCellDim);
      y0 = Math.max(0, y0);
      var y1 = Math.floor((qy + threshold) / Grid.prototype.minCellDim);
      y1 = Math.min(Grid.prototype.field[0].length - 1, y1);

      var candidates = [];
      for (var x = x0; x <= x1; ++x) {
        for (var y = y0; y <= y1; ++y) {
          candidates.push.apply(candidates, Grid.prototype.field[x][y]);
        }
      }

      var neighbors = [];
      var tsqr = threshold * threshold;
      var numCandidates = candidates.length;
      for (var idxCandidate = 0; idxCandidate < numCandidates; ++idxCandidate) {
        var candidateID = candidates[idxCandidate];
        var cpos = Grid.prototype.positions[candidateID];
        var dx = cpos[0] - qx;
        var dy = cpos[1] - qy;
        var dsqr = dx*dx + dy*dy;
        if (dsqr <= tsqr && dsqr > nearlyZero) {
          neighbors.push(Math.ceil(dsqr) * scaleFactor + candidateID);
        }
      }
      // sort neighbors to get the closest
      neighbors = neighbors.sort(function(a,b){return a-b});
      neighbors = neighbors.slice(0, maxNeighbors);
      // strip off the position info to leave the IDs
      Boid.prototype.neighbors[idxBoid] = neighbors.map(function(x){return x % scaleFactor});
    }
  }

  return Grid;
})();


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var Boid = __webpack_require__(0);

module.exports = (function () {
  Flock.prototype.sources = [];

  function Flock(grid) {
    this.grid = grid;
    this.numActive = 0;
    this.boids = [];
    this.neighborDist = 75;
    this.maxNeighbors = 10;
  }

  Flock.prototype.constructor = Flock

  function createBoid() {
    var numSources = Flock.prototype.sources.length;
    var idxSource = randomInRange(0, numSources - 1, true);
    var src = Flock.prototype.sources[idxSource];
    var p = [src[0], src[1]];
    p[0] += Math.random() * 6 - 3;
    p[1] += Math.random() * 6 - 3;

    // set velocity (aka heading)
    var v = [(Math.random() - 0.5), (Math.random() - 0.5)];
    v = normalize(v);

    return new Boid(p, v);
  }

  Flock.prototype.createSource = function (x, y) {
    let nextSourceIdx = Flock.prototype.sources.length;
    Flock.prototype.sources[nextSourceIdx] = [x, y];
  }

  Flock.prototype.createBoids = function (numBoids) {
    this.numDesired = numBoids;
  }

  Flock.prototype.spawn = function (dt) {
    var numBoids = this.boids.length;
    this.numActive = Math.min(numBoids, this.numActive);
    if (this.numActive < this.numDesired) {
      ++this.numActive;
      if (this.numActive > numBoids) {
        this.boids[numBoids] = createBoid();
      }
    }
  }

  Flock.prototype.update = function (dt) {
    for (let idxBoid = 0; idxBoid < this.numActive; ++idxBoid) {
      this.boids[idxBoid].update(dt);
      this.boids[idxBoid].move(dt);
    }

    this.grid.add(Boid.prototype.pos);
    this.grid.findNeighbors(this.neighborDist, this.maxNeighbors);

    for (let idxBoid = 0; idxBoid < this.numActive; ++idxBoid) {
      Boid.prototype.centroid[idxBoid] = findGroupCentroid(idxBoid);
    }
  }

  function findGroupCentroid(boidId) {
    var neighbors = Boid.prototype.neighbors[boidId]
    var numNeighbors = neighbors.length;
    var bp = Boid.prototype.pos[boidId];
    var goal = [bp[0], bp[1]];
    for (var i = 0; i < numNeighbors; ++i) {
      var nid = neighbors[i];
      var np = Boid.prototype.pos[nid];

      goal[0] += np[0];
      goal[1] += np[1];
    }
    goal[0] /= numNeighbors+1;
    goal[1] /= numNeighbors+1;

    return goal;
  }

  Flock.prototype.debugDraw = function (context) {
    let numBoids = this.boids.length;
    let specialBoidId = 0;
    let skipRegularBoids = true;

    for (let idxBoid = 0; idxBoid < numBoids; ++idxBoid) {
      if (skipRegularBoids && idxBoid != specialBoidId) {
        continue;
      }

      var bp = Boid.prototype.pos[idxBoid];

      // draw neighborDist range
      drawCircle(context, bp[0], bp[1], this.neighborDist, 'darkgray', 0.5);

      var neighbors = Boid.prototype.neighbors[idxBoid];
      var numNeighbors = neighbors.length;
      if (numNeighbors > 0) {
        context.strokeStyle = "red"; //"hsla(" + this.hue + ",100%,50%,1)";
        context.lineWidth = 0.5;
        context.beginPath();
        let pos = Boid.prototype.centroid[idxBoid];
        for (var i = 0; i < numNeighbors; ++i) {
          context.moveTo(pos[0], pos[1]);
          var nid = neighbors[i];
          var np = Boid.prototype.pos[nid];
          context.lineTo(np[0], np[1]);
          context.stroke();
        }

        context.moveTo(pos[0], pos[1]);
        context.lineTo(bp[0], bp[1]);
        context.stroke();

        xyz(context, pos[0], pos[1], 2, "white");
      }
    }
  }

  function drawCircle(context, x, y, radius, color, width) {
    context.moveTo(x + radius, y)
    context.arc(x, y, radius, 0, 2*Math.PI, false);
    context.lineWidth = width;
    context.strokeStyle = color;
    context.stroke();
  }

  function xyz(context, x, y, radius, color) {
    context.beginPath();
    context.fillStyle = color;
    context.arc(x, y, radius, 0, 2*Math.PI, false);
    context.fill();
  }

  Flock.prototype.draw = function(context) {
    var numBoids = this.boids.length;
    for (var idxBoid = 0; idxBoid < numBoids; ++idxBoid) {
      this.boids[idxBoid].draw(context);
    }
  }

  return Flock;
})();


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class Mildo {
  constructor() {
    console.log("MILDO");
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Mildo;



/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZWE2ZjAyMTYyMGU5Y2M0NDhiODAiLCJ3ZWJwYWNrOi8vLy4vanMvQm9pZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9zbXUuanMiLCJ3ZWJwYWNrOi8vLy4vanMvZ3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9mbG9jay5qcyIsIndlYnBhY2s6Ly8vLi9qcy9taWxkby5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUIsMEJBQTBCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7O0FDaEpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBIiwiZmlsZSI6ImluZGV4Lm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGVhNmYwMjE2MjBlOWNjNDQ4YjgwIiwibW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICBCb2lkLnByb3RvdHlwZS5udW1Cb2lkcyA9IDA7XG4gIEJvaWQucHJvdG90eXBlLnBvcyA9IFtdO1xuICBCb2lkLnByb3RvdHlwZS52ZWwgPSBbXTtcbiAgQm9pZC5wcm90b3R5cGUubmVpZ2hib3JzID0gW107XG4gIEJvaWQucHJvdG90eXBlLmNlbnRyb2lkID0gW107XG5cbiAgZnVuY3Rpb24gQm9pZChwb3MsIHZlbCkge1xuICAgIHRoaXMuaWQgPSBCb2lkLnByb3RvdHlwZS5udW1Cb2lkcysrO1xuICAgIEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXSA9IHBvcztcbiAgICBCb2lkLnByb3RvdHlwZS52ZWxbdGhpcy5pZF0gPSB2ZWw7XG4gICAgQm9pZC5wcm90b3R5cGUubmVpZ2hib3JzW3RoaXMuaWRdID0gW107XG4gIH1cblxuICBCb2lkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJvaWRcblxuICBCb2lkLnByb3RvdHlwZS5zZXBhcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmVpZ2hib3JzID0gQm9pZC5wcm90b3R5cGUubmVpZ2hib3JzW3RoaXMuaWRdXG4gICAgdmFyIG51bU5laWdoYm9ycyA9IG5laWdoYm9ycy5sZW5ndGg7XG4gICAgdmFyIGF2ID0gWzAsIDBdO1xuICAgIHZhciBicCA9IEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXTtcbiAgICB2YXIgdGhyZXNob2xkID0gMTAwKjEwMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5laWdoYm9yczsgKytpKSB7XG4gICAgICB2YXIgbmlkID0gbmVpZ2hib3JzW2ldO1xuICAgICAgdmFyIG5wID0gQm9pZC5wcm90b3R5cGUucG9zW25pZF07XG5cbiAgICAgIHZhciBkID0gWzAsIDBdO1xuICAgICAgZFswXSA9IGJwWzBdIC0gbnBbMF07XG4gICAgICBkWzFdID0gYnBbMV0gLSBucFsxXTtcbiAgICAgIHZhciBkcyA9IGRbMF0qZFswXSArIGRbMV0qZFsxXTtcbiAgICAgIGlmIChkcyA8IHRocmVzaG9sZCkge1xuICAgICAgICAvLyBOT1RFIGFkZCBmYWN0b3IgdG8gcHJldmVudCBkaXZpZGUgYnkgMFxuICAgICAgICBkcyArPSAwLjE7XG4gICAgICAgIHZhciBmYWN0b3IgPSB0aHJlc2hvbGQgLyBkcztcbiAgICAgICAgYXZbMF0gKz0gZFswXSAqIGZhY3RvcjtcbiAgICAgICAgYXZbMV0gKz0gZFsxXSAqIGZhY3RvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgYXYgPSBub3JtYWxpemUoYXYpO1xuXG4gICAgcmV0dXJuIGF2O1xuICB9XG5cbiAgQm9pZC5wcm90b3R5cGUuY29oZXJlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdiA9IFswLCAwXTtcbiAgICBpZiAoQm9pZC5wcm90b3R5cGUubmVpZ2hib3JzW3RoaXMuaWRdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGN2O1xuICAgIH1cblxuICAgIGdvYWwgPSBCb2lkLnByb3RvdHlwZS5jZW50cm9pZFt0aGlzLmlkXTtcbiAgICB2YXIgYnAgPSBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF07XG4gICAgY3ZbMF0gPSBnb2FsWzBdIC0gYnBbMF07XG4gICAgY3ZbMV0gPSBnb2FsWzFdIC0gYnBbMV07XG4gICAgcmV0dXJuIGN2O1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhbXBlcigpIHtcblxuICB9XG5cbiAgQm9pZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGR0KSB7XG4gICAgLy8gdmVsb2NpdHkgbW9kaWZpZXJzXG4gICAgdmFyIHN2ID0gdGhpcy5zZXBhcmF0ZSgpO1xuICAgIHZhciBzZiA9IDAuMDtcblxuICAgIHZhciBjdiA9IHRoaXMuY29oZXJlKCk7XG4gICAgLy8gbGV0IGRpc3QyID0gZG90KGN2LCBjdik7XG4gICAgLy8gaWYgKGRpc3QyIDwgNCB8fCBkaXN0MiA+IDEyMCkge1xuICAgIC8vICAgY3YgPSBbMCwgMF07XG4gICAgLy8gfVxuICAgIHZhciBjZiA9IDAuMDtcblxuICAgIC8vLS0tLVxuICAgIGxldCBidmMgPSAwLjk5OTk5OTk5O1xuICAgIHZhciBidiA9IEJvaWQucHJvdG90eXBlLnZlbFt0aGlzLmlkXTtcblxuICAgIHZhciB2bSA9IFswLCAwXTtcbiAgICB2bVswXSA9IHNmKnN2WzBdICsgY2YqY3ZbMF0gKyBidmMqYnZbMF07XG4gICAgdm1bMV0gPSBzZipzdlsxXSArIGNmKmN2WzFdICsgYnZjKmJ2WzFdO1xuXG4gICAgbGV0IHZsID0gTWF0aC5zcXJ0KGRvdCh2bSwgdm0pKTtcbiAgICBpZiAodmwgPiA0KSB7XG4gICAgICB2bSA9IG5vcm1hbGl6ZSh2bSk7XG4gICAgICB2bVswXSAqPSA0O1xuICAgICAgdm1bMV0gKj0gNDtcbiAgICB9XG5cbiAgICBCb2lkLnByb3RvdHlwZS52ZWxbdGhpcy5pZF0gPSB2bTtcbiAgfVxuXG4gIEJvaWQucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoZHQpIHtcbiAgICBsZXQgdmMgPSAxO1xuICAgIEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVswXSArPSAodmMgKiBCb2lkLnByb3RvdHlwZS52ZWxbdGhpcy5pZF1bMF0pO1xuICAgIEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVsxXSArPSAodmMgKiBCb2lkLnByb3RvdHlwZS52ZWxbdGhpcy5pZF1bMV0pO1xuXG4gICAgLy8ga2VlcCBib2lkIHdpdGhpbiBsaW1pdHNcbiAgICB2YXIgd2lkdGggPSAyMDA7IC8vY29udGV4dC5jYW52YXMud2lkdGggLSAxO1xuICAgIHZhciBoZWlnaHQgPSAyMDA7IC8vY29udGV4dC5jYW52YXMuaGVpZ2h0IC0gMTtcblxuICAgIHZhciBieCA9IEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVswXTtcbiAgICBpZiAoYnggPj0gd2lkdGgpIHtcbiAgICAgIEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVswXSA9IDA7IC8vIGJ4IC0gd2lkdGg7XG4gICAgfSBlbHNlIGlmIChieCA8IDApIHtcbiAgICAgIEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVswXSA9IHdpZHRoOyAvLyBieCArIHdpZHRoO1xuICAgIH1cblxuICAgIHZhciBieSA9IEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVsxXTtcbiAgICBpZiAoYnkgPj0gaGVpZ2h0KSB7XG4gICAgICBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMV0gPSAwOyAvLyBieSAtIGhlaWdodDtcbiAgICB9IGVsc2UgaWYgKGJ5IDwgMCkge1xuICAgICAgQm9pZC5wcm90b3R5cGUucG9zW3RoaXMuaWRdWzFdID0gaGVpZ2h0OyAvLyBieSArIGhlaWdodDtcbiAgICB9XG4gIH1cblxuICBCb2lkLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG5cbiAgICB2YXIgeCA9IEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVswXTtcbiAgICB2YXIgeSA9IEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVsxXTtcblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBcImJsdWVcIjtcbiAgICBpZiAodGhpcy5pZCAhPSAwKSB7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwieWVsbG93XCI7XG4gICAgfVxuICAgIGNvbnRleHQuYXJjKHgsIHksIDQsIDAsIDIqTWF0aC5QSSwgZmFsc2UpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2F5SXQoKSB7XG4gICAgY29uc29sZS5sb2coXCJIRUVCRUUgSkVFQkVFXCIpO1xuICB9XG5cbiAgQm9pZC5wcm90b3R5cGUuYmxhaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzYXlJdCgpO1xuICB9XG5cbiAgcmV0dXJuIEJvaWQ7XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9Cb2lkLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vc211LmpzJyk7XG4vLyBpbXBvcnQgQm9pZCBmcm9tICcuL0JvaWQnXG52YXIgR3JpZCA9IHJlcXVpcmUoJy4vZ3JpZCcpO1xudmFyIEZsb2NrID0gcmVxdWlyZSgnLi9mbG9jay5qcycpO1xuaW1wb3J0IE1pbGRvIGZyb20gJy4vbWlsZG8nO1xuXG4vLy0tWyBzdGVwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc3RlcCh0aW1lc3RhbXApIHtcbiAgbGV0IGZyYW1lVGltZU1zID0gdGltZXN0YW1wIC0gbGFzdDtcbiAgbGFzdCA9IHRpbWVzdGFtcDtcbiAgLy8gY29uc29sZS5sb2coZnJhbWVUaW1lTXMpO1xuXG4gIC8vIGZyYW1lcyBwZXIgc2Vjb25kXG4gIGxldCBlbGFwc2VkVGltZSA9ICh0aW1lc3RhbXAgLSBzdGFydFRpbWUpIC8gMTAwMCxcbiAgcmVzdWx0ID0gTWF0aC5mbG9vcigoZnJhbWUgLyBlbGFwc2VkVGltZSkpO1xuICBpZiAoZWxhcHNlZFRpbWUgPiAxKSB7XG4gICAgc3RhcnRUaW1lID0gdGltZXN0YW1wO1xuICAgIGZyYW1lID0gMDtcbiAgfVxuICBpZiAoZnJhbWUgJSAxMCA9PSAwKSB7XG4gICAgbGV0IGZwc1RleHQgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAvLyBjb25zb2xlLmxvZyhmcHNUZXh0KTtcbiAgfVxuICArK2ZyYW1lO1xuXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgaWYgKGZyYW1lICUgMyA9PT0gMCkge1xuICAgIGYudXBkYXRlKHRpbWVzdGFtcCk7XG4gIH1cbiAgZi5zcGF3bigwKTtcbiAgZi5kZWJ1Z0RyYXcoY29udGV4dCk7XG4gIGYuZHJhdyhjb250ZXh0KTtcblxuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIGxhc3QgPSBwZXJmb3JtYW5jZS5ub3coKTtcbnZhciBzdGFydFRpbWUgPSBsYXN0O1xudmFyIGZyYW1lID0gMDtcblxubGV0IG0gPSBuZXcgTWlsZG8oKTtcblxubGV0IHd3ID0gd2luZG93LmlubmVyV2lkdGg7XG5sZXQgd2ggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG52YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpZWxkJyk7XG52YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuY29udGV4dC5jYW52YXMud2lkdGggPSB3dztcbmNvbnRleHQuY2FudmFzLmhlaWdodCA9IHdoO1xuXG5sZXQgZyA9IG5ldyBHcmlkKHd3LCB3aCwgMTAwKTtcbmxldCBmID0gbmV3IEZsb2NrKGcpO1xuZi5jcmVhdGVCb2lkcygxMDApO1xuLy9mLmNyZWF0ZVNvdXJjZSh3dyAvIDIsIHdoIC8gMik7XG5mLmNyZWF0ZVNvdXJjZSgyNSwgMjUpO1xuXG53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL1xuLy8gU2ltdWxhdGlvbiBNYXRoIFV0aWxpdGllc1xuLy9cbmlmIChtb2R1bGUgPT09IHVuZGVmaW5lZCkge1xuICB2YXIgbW9kdWxlID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5uZWFybHlaZXJvID0gMC4wMDAxO1xuXG4gIHRoaXMubm9ybWFsaXplID0gZnVuY3Rpb24gKHYpIHtcbiAgICBsZXQgbHYgPSBNYXRoLnNxcnQodlswXSp2WzBdICsgdlsxXSp2WzFdKTtcbiAgICBpZiAoTWF0aC5hYnMobHYpID4gbmVhcmx5WmVybykge1xuICAgICAgdlswXSAvPSBsdjtcbiAgICAgIHZbMV0gLz0gbHY7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG5cbiAgdGhpcy5kb3QgPSBmdW5jdGlvbih2MSwgdjIpIHtcbiAgICByZXR1cm4gdjFbMF0qdjJbMF0gKyB2MVsxXSp2MlsxXVxuICB9XG5cbiAgdGhpcy5idWlsZFJvdGF0aW9uTWF0cml4ID0gZnVuY3Rpb24oZGVncmVlcykge1xuICAgIHZhciByYWRpYW5zID0gZGVncmVlcyAqIE1hdGguUEkgLyAxODAuMDtcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgW01hdGguY29zKHJhZGlhbnMpLCAtTWF0aC5zaW4ocmFkaWFucyldLFxuICAgICAgW01hdGguc2luKHJhZGlhbnMpLCBNYXRoLmNvcyhyYWRpYW5zKV0sXG4gICAgXTtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG5cbiAgdGhpcy5yb3RhdGUgPSBmdW5jdGlvbih2LCBtKSB7XG4gICAgdmFyIHggPSBtWzBdWzBdKnZbMF0gKyBtWzBdWzFdKnZbMV1cbiAgICB2YXIgeSA9IG1bMV1bMF0qdlswXSArIG1bMV1bMV0qdlsxXVxuICAgIHJldHVybiBbeCwgeV07XG4gIH1cblxuICB0aGlzLnJhbmRvbUluUmFuZ2UgPSBmdW5jdGlvbihtaW4sIG1heCwgd2FudEludCkge1xuICAgIHZhciBtYXggPSAobWF4ID09PSAwIHx8IG1heCkgPyBtYXggOiAxLFxuICAgICAgICBtaW4gPSBtaW4gfHwgMCxcbiAgICAgICAgZ2VuID0gbWluICsgKG1heCAtIG1pbikgKiBNYXRoLnJhbmRvbSgpO1xuXG4gICAgcmV0dXJuICh3YW50SW50KSA/IE1hdGgucm91bmQoZ2VuKSA6IGdlbjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgZG90OiBkb3QsXG4gICAgYnVpbGRSb3RhdGlvbk1hdHJpeDogYnVpbGRSb3RhdGlvbk1hdHJpeCxcbiAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICByYW5kb21JblJhbmdlOiByYW5kb21JblJhbmdlXG4gIH07XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9zbXUuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEJvaWQgPSByZXF1aXJlKCcuL0JvaWQuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBtb3ZlIHRvIHJlc2V0IGZuP1xuICBHcmlkLnByb3RvdHlwZS53aWR0aCA9IDA7XG4gIEdyaWQucHJvdG90eXBlLmhlaWdodCA9IDA7XG4gIEdyaWQucHJvdG90eXBlLmN4ID0gMDtcbiAgR3JpZC5wcm90b3R5cGUuY3kgPSAwO1xuICBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltID0gMDtcbiAgR3JpZC5wcm90b3R5cGUuZmllbGQgPSBbXTtcblxuICBmdW5jdGlvbiBHcmlkKHdpZHRoLCBoZWlnaHQsIG1pbkNlbGxEaW0pIHtcbiAgICAvLyB4XG4gICAgR3JpZC5wcm90b3R5cGUud2lkdGggPSB3aWR0aDtcbiAgICBHcmlkLnByb3RvdHlwZS5jeCA9IE1hdGguY2VpbCh3aWR0aCAvIG1pbkNlbGxEaW0pO1xuXG4gICAgLy8geVxuICAgIEdyaWQucHJvdG90eXBlLmhlaWdodCA9IGhlaWdodDtcbiAgICBHcmlkLnByb3RvdHlwZS5jeSA9IE1hdGguY2VpbChoZWlnaHQgLyBtaW5DZWxsRGltKTtcblxuICAgIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0gPSBtaW5DZWxsRGltO1xuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBHcmlkLnByb3RvdHlwZS5jeDsgKyt4KSB7XG4gICAgICBHcmlkLnByb3RvdHlwZS5maWVsZFt4XSA9IFtdXG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IEdyaWQucHJvdG90eXBlLmN5OyArK3kpIHtcbiAgICAgICAgR3JpZC5wcm90b3R5cGUuZmllbGRbeF0ucHVzaChbXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVuZGl0ID0gMDtcbiAgfVxuXG4gIEdyaWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JpZDtcblxuICBHcmlkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihwb3NpdGlvbnMpIHtcbiAgICAvLyBjbGVhciB0aGUgZ3JpZFxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgR3JpZC5wcm90b3R5cGUuZmllbGQubGVuZ3RoOyArK3gpIHtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgR3JpZC5wcm90b3R5cGUuZmllbGRbMF0ubGVuZ3RoOyArK3kpIHtcbiAgICAgICAgR3JpZC5wcm90b3R5cGUuZmllbGRbeF1beV0gPSBbXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRvIHRoZSBhZGRpbmdcbiAgICB2YXIgbnVtUG9zaXRpb25zID0gcG9zaXRpb25zLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpZHhQb3MgPSAwOyBpZHhQb3MgPCBudW1Qb3NpdGlvbnM7ICsraWR4UG9zKSB7XG4gICAgICB2YXIgYnAgPSBwb3NpdGlvbnNbaWR4UG9zXTtcbiAgICAgIHZhciB4YyA9IE1hdGguZmxvb3IoYnBbMF0gLyBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltKTtcbiAgICAgIHZhciB5YyA9IE1hdGguZmxvb3IoYnBbMV0gLyBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltKTtcbiAgICAgIGlmIChHcmlkLnByb3RvdHlwZS5maWVsZFt4Y10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgYnJlYWtfaGVyZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBHcmlkLnByb3RvdHlwZS5maWVsZFt4Y11beWNdLnB1c2goaWR4UG9zKTtcbiAgICAgIC8vIGNvbG9yIGJvaWRzIGJhc2VkIG9uIHBvc2l0aW9uXG4gICAgICAvLyBCb2lkLnByb3RvdHlwZS5odWVbaWR4UG9zXSA9ICgoeWMgKyB4YykgJSAyKSA9PSAwID8gXCJibHVlXCIgOiBcImdyZWVuXCJcbiAgICB9XG5cbiAgICAvLyBzYXZlIHRoZSBwb3NpdGlvbnMgZm9yIHRoZSBxdWVyaWVzXG4gICAgR3JpZC5wcm90b3R5cGUucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICB9XG5cbiAgR3JpZC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihteCwgbXkpIHtcbiAgICB2YXIgeGMgPSBNYXRoLmZsb29yKG14IC8gR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSk7XG4gICAgdmFyIHljID0gTWF0aC5mbG9vcihteSAvIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0pO1xuXG4gICAgdmFyIHNlbGVjdGVkSUQgPSBudWxsO1xuICAgIHZhciBtaW5Ub0JvaWRTcXIgPSBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltICogR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbTtcbiAgICB2YXIgY2FuZGlkYXRlcyA9IEdyaWQucHJvdG90eXBlLmZpZWxkW3hjXVt5Y107XG4gICAgdmFyIG51bUNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpZHhDYW5kaWRhdGUgPSAwOyBpZHhDYW5kaWRhdGUgPCBudW1DYW5kaWRhdGVzOyArK2lkeENhbmRpZGF0ZSkge1xuICAgICAgdmFyIGNhbmRpZGF0ZUlEID0gY2FuZGlkYXRlc1tpZHhDYW5kaWRhdGVdO1xuICAgICAgdmFyIHBvcyA9IEdyaWQucHJvdG90eXBlLnBvc2l0aW9uc1tjYW5kaWRhdGVJRF07XG4gICAgICB2YXIgZHggPSBwb3NbMF0gLSBteDtcbiAgICAgIHZhciBkeSA9IHBvc1sxXSAtIG15O1xuICAgICAgdmFyIHRvQm9pZFNxciA9IGR4KmR4ICsgZHkqZHk7XG4gICAgICBpZiAodG9Cb2lkU3FyIDwgMTIxICYmIHRvQm9pZFNxciA8IG1pblRvQm9pZFNxcikge1xuICAgICAgICBzZWxlY3RlZElEID0gY2FuZGlkYXRlSUQ7XG4gICAgICAgIG1pblRvQm9pZFNxciA9IHRvQm9pZFNxcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0ZWRJRDtcbiAgfVxuXG4gIEdyaWQucHJvdG90eXBlLmZpbmROZWlnaGJvcnMgPSBmdW5jdGlvbih0aHJlc2hvbGQsIG1heE5laWdoYm9ycykge1xuICAgIHZhciBzY2FsZUZhY3RvciA9IDEwMDA7XG4gICAgdmFyIG51bUJvaWRzID0gQm9pZC5wcm90b3R5cGUubnVtQm9pZHM7XG5cbiAgICBmb3IgKHZhciBpZHhCb2lkID0gMDsgaWR4Qm9pZCA8IG51bUJvaWRzOyArK2lkeEJvaWQpIHtcbiAgICAgIHZhciBicCA9IEJvaWQucHJvdG90eXBlLnBvc1tpZHhCb2lkXTtcbiAgICAgIHZhciBxeCA9IGJwWzBdO1xuICAgICAgdmFyIHF5ID0gYnBbMV07XG5cbiAgICAgIHZhciB4MCA9IE1hdGguZmxvb3IoKHF4IC0gdGhyZXNob2xkKSAvIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0pO1xuICAgICAgeDAgPSBNYXRoLm1heCgwLCB4MCk7XG4gICAgICB2YXIgeDEgPSBNYXRoLmZsb29yKChxeCArIHRocmVzaG9sZCkgLyBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltKTtcbiAgICAgIHgxID0gTWF0aC5taW4oR3JpZC5wcm90b3R5cGUuZmllbGQubGVuZ3RoIC0gMSwgeDEpO1xuICAgICAgdmFyIHkwID0gTWF0aC5mbG9vcigocXkgLSB0aHJlc2hvbGQpIC8gR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSk7XG4gICAgICB5MCA9IE1hdGgubWF4KDAsIHkwKTtcbiAgICAgIHZhciB5MSA9IE1hdGguZmxvb3IoKHF5ICsgdGhyZXNob2xkKSAvIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0pO1xuICAgICAgeTEgPSBNYXRoLm1pbihHcmlkLnByb3RvdHlwZS5maWVsZFswXS5sZW5ndGggLSAxLCB5MSk7XG5cbiAgICAgIHZhciBjYW5kaWRhdGVzID0gW107XG4gICAgICBmb3IgKHZhciB4ID0geDA7IHggPD0geDE7ICsreCkge1xuICAgICAgICBmb3IgKHZhciB5ID0geTA7IHkgPD0geTE7ICsreSkge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaC5hcHBseShjYW5kaWRhdGVzLCBHcmlkLnByb3RvdHlwZS5maWVsZFt4XVt5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5laWdoYm9ycyA9IFtdO1xuICAgICAgdmFyIHRzcXIgPSB0aHJlc2hvbGQgKiB0aHJlc2hvbGQ7XG4gICAgICB2YXIgbnVtQ2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaWR4Q2FuZGlkYXRlID0gMDsgaWR4Q2FuZGlkYXRlIDwgbnVtQ2FuZGlkYXRlczsgKytpZHhDYW5kaWRhdGUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZUlEID0gY2FuZGlkYXRlc1tpZHhDYW5kaWRhdGVdO1xuICAgICAgICB2YXIgY3BvcyA9IEdyaWQucHJvdG90eXBlLnBvc2l0aW9uc1tjYW5kaWRhdGVJRF07XG4gICAgICAgIHZhciBkeCA9IGNwb3NbMF0gLSBxeDtcbiAgICAgICAgdmFyIGR5ID0gY3Bvc1sxXSAtIHF5O1xuICAgICAgICB2YXIgZHNxciA9IGR4KmR4ICsgZHkqZHk7XG4gICAgICAgIGlmIChkc3FyIDw9IHRzcXIgJiYgZHNxciA+IG5lYXJseVplcm8pIHtcbiAgICAgICAgICBuZWlnaGJvcnMucHVzaChNYXRoLmNlaWwoZHNxcikgKiBzY2FsZUZhY3RvciArIGNhbmRpZGF0ZUlEKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gc29ydCBuZWlnaGJvcnMgdG8gZ2V0IHRoZSBjbG9zZXN0XG4gICAgICBuZWlnaGJvcnMgPSBuZWlnaGJvcnMuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLWJ9KTtcbiAgICAgIG5laWdoYm9ycyA9IG5laWdoYm9ycy5zbGljZSgwLCBtYXhOZWlnaGJvcnMpO1xuICAgICAgLy8gc3RyaXAgb2ZmIHRoZSBwb3NpdGlvbiBpbmZvIHRvIGxlYXZlIHRoZSBJRHNcbiAgICAgIEJvaWQucHJvdG90eXBlLm5laWdoYm9yc1tpZHhCb2lkXSA9IG5laWdoYm9ycy5tYXAoZnVuY3Rpb24oeCl7cmV0dXJuIHggJSBzY2FsZUZhY3Rvcn0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBHcmlkO1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vanMvZ3JpZC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQm9pZCA9IHJlcXVpcmUoJy4vQm9pZC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gIEZsb2NrLnByb3RvdHlwZS5zb3VyY2VzID0gW107XG5cbiAgZnVuY3Rpb24gRmxvY2soZ3JpZCkge1xuICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgdGhpcy5udW1BY3RpdmUgPSAwO1xuICAgIHRoaXMuYm9pZHMgPSBbXTtcbiAgICB0aGlzLm5laWdoYm9yRGlzdCA9IDc1O1xuICAgIHRoaXMubWF4TmVpZ2hib3JzID0gMTA7XG4gIH1cblxuICBGbG9jay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGbG9ja1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJvaWQoKSB7XG4gICAgdmFyIG51bVNvdXJjZXMgPSBGbG9jay5wcm90b3R5cGUuc291cmNlcy5sZW5ndGg7XG4gICAgdmFyIGlkeFNvdXJjZSA9IHJhbmRvbUluUmFuZ2UoMCwgbnVtU291cmNlcyAtIDEsIHRydWUpO1xuICAgIHZhciBzcmMgPSBGbG9jay5wcm90b3R5cGUuc291cmNlc1tpZHhTb3VyY2VdO1xuICAgIHZhciBwID0gW3NyY1swXSwgc3JjWzFdXTtcbiAgICBwWzBdICs9IE1hdGgucmFuZG9tKCkgKiA2IC0gMztcbiAgICBwWzFdICs9IE1hdGgucmFuZG9tKCkgKiA2IC0gMztcblxuICAgIC8vIHNldCB2ZWxvY2l0eSAoYWthIGhlYWRpbmcpXG4gICAgdmFyIHYgPSBbKE1hdGgucmFuZG9tKCkgLSAwLjUpLCAoTWF0aC5yYW5kb20oKSAtIDAuNSldO1xuICAgIHYgPSBub3JtYWxpemUodik7XG5cbiAgICByZXR1cm4gbmV3IEJvaWQocCwgdik7XG4gIH1cblxuICBGbG9jay5wcm90b3R5cGUuY3JlYXRlU291cmNlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBsZXQgbmV4dFNvdXJjZUlkeCA9IEZsb2NrLnByb3RvdHlwZS5zb3VyY2VzLmxlbmd0aDtcbiAgICBGbG9jay5wcm90b3R5cGUuc291cmNlc1tuZXh0U291cmNlSWR4XSA9IFt4LCB5XTtcbiAgfVxuXG4gIEZsb2NrLnByb3RvdHlwZS5jcmVhdGVCb2lkcyA9IGZ1bmN0aW9uIChudW1Cb2lkcykge1xuICAgIHRoaXMubnVtRGVzaXJlZCA9IG51bUJvaWRzO1xuICB9XG5cbiAgRmxvY2sucHJvdG90eXBlLnNwYXduID0gZnVuY3Rpb24gKGR0KSB7XG4gICAgdmFyIG51bUJvaWRzID0gdGhpcy5ib2lkcy5sZW5ndGg7XG4gICAgdGhpcy5udW1BY3RpdmUgPSBNYXRoLm1pbihudW1Cb2lkcywgdGhpcy5udW1BY3RpdmUpO1xuICAgIGlmICh0aGlzLm51bUFjdGl2ZSA8IHRoaXMubnVtRGVzaXJlZCkge1xuICAgICAgKyt0aGlzLm51bUFjdGl2ZTtcbiAgICAgIGlmICh0aGlzLm51bUFjdGl2ZSA+IG51bUJvaWRzKSB7XG4gICAgICAgIHRoaXMuYm9pZHNbbnVtQm9pZHNdID0gY3JlYXRlQm9pZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIEZsb2NrLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZHQpIHtcbiAgICBmb3IgKGxldCBpZHhCb2lkID0gMDsgaWR4Qm9pZCA8IHRoaXMubnVtQWN0aXZlOyArK2lkeEJvaWQpIHtcbiAgICAgIHRoaXMuYm9pZHNbaWR4Qm9pZF0udXBkYXRlKGR0KTtcbiAgICAgIHRoaXMuYm9pZHNbaWR4Qm9pZF0ubW92ZShkdCk7XG4gICAgfVxuXG4gICAgdGhpcy5ncmlkLmFkZChCb2lkLnByb3RvdHlwZS5wb3MpO1xuICAgIHRoaXMuZ3JpZC5maW5kTmVpZ2hib3JzKHRoaXMubmVpZ2hib3JEaXN0LCB0aGlzLm1heE5laWdoYm9ycyk7XG5cbiAgICBmb3IgKGxldCBpZHhCb2lkID0gMDsgaWR4Qm9pZCA8IHRoaXMubnVtQWN0aXZlOyArK2lkeEJvaWQpIHtcbiAgICAgIEJvaWQucHJvdG90eXBlLmNlbnRyb2lkW2lkeEJvaWRdID0gZmluZEdyb3VwQ2VudHJvaWQoaWR4Qm9pZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZEdyb3VwQ2VudHJvaWQoYm9pZElkKSB7XG4gICAgdmFyIG5laWdoYm9ycyA9IEJvaWQucHJvdG90eXBlLm5laWdoYm9yc1tib2lkSWRdXG4gICAgdmFyIG51bU5laWdoYm9ycyA9IG5laWdoYm9ycy5sZW5ndGg7XG4gICAgdmFyIGJwID0gQm9pZC5wcm90b3R5cGUucG9zW2JvaWRJZF07XG4gICAgdmFyIGdvYWwgPSBbYnBbMF0sIGJwWzFdXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5laWdoYm9yczsgKytpKSB7XG4gICAgICB2YXIgbmlkID0gbmVpZ2hib3JzW2ldO1xuICAgICAgdmFyIG5wID0gQm9pZC5wcm90b3R5cGUucG9zW25pZF07XG5cbiAgICAgIGdvYWxbMF0gKz0gbnBbMF07XG4gICAgICBnb2FsWzFdICs9IG5wWzFdO1xuICAgIH1cbiAgICBnb2FsWzBdIC89IG51bU5laWdoYm9ycysxO1xuICAgIGdvYWxbMV0gLz0gbnVtTmVpZ2hib3JzKzE7XG5cbiAgICByZXR1cm4gZ29hbDtcbiAgfVxuXG4gIEZsb2NrLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGxldCBudW1Cb2lkcyA9IHRoaXMuYm9pZHMubGVuZ3RoO1xuICAgIGxldCBzcGVjaWFsQm9pZElkID0gMDtcbiAgICBsZXQgc2tpcFJlZ3VsYXJCb2lkcyA9IHRydWU7XG5cbiAgICBmb3IgKGxldCBpZHhCb2lkID0gMDsgaWR4Qm9pZCA8IG51bUJvaWRzOyArK2lkeEJvaWQpIHtcbiAgICAgIGlmIChza2lwUmVndWxhckJvaWRzICYmIGlkeEJvaWQgIT0gc3BlY2lhbEJvaWRJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJwID0gQm9pZC5wcm90b3R5cGUucG9zW2lkeEJvaWRdO1xuXG4gICAgICAvLyBkcmF3IG5laWdoYm9yRGlzdCByYW5nZVxuICAgICAgZHJhd0NpcmNsZShjb250ZXh0LCBicFswXSwgYnBbMV0sIHRoaXMubmVpZ2hib3JEaXN0LCAnZGFya2dyYXknLCAwLjUpO1xuXG4gICAgICB2YXIgbmVpZ2hib3JzID0gQm9pZC5wcm90b3R5cGUubmVpZ2hib3JzW2lkeEJvaWRdO1xuICAgICAgdmFyIG51bU5laWdoYm9ycyA9IG5laWdoYm9ycy5sZW5ndGg7XG4gICAgICBpZiAobnVtTmVpZ2hib3JzID4gMCkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJyZWRcIjsgLy9cImhzbGEoXCIgKyB0aGlzLmh1ZSArIFwiLDEwMCUsNTAlLDEpXCI7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMC41O1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBsZXQgcG9zID0gQm9pZC5wcm90b3R5cGUuY2VudHJvaWRbaWR4Qm9pZF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTmVpZ2hib3JzOyArK2kpIHtcbiAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb3NbMF0sIHBvc1sxXSk7XG4gICAgICAgICAgdmFyIG5pZCA9IG5laWdoYm9yc1tpXTtcbiAgICAgICAgICB2YXIgbnAgPSBCb2lkLnByb3RvdHlwZS5wb3NbbmlkXTtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhucFswXSwgbnBbMV0pO1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb3NbMF0sIHBvc1sxXSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKGJwWzBdLCBicFsxXSk7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAgICAgeHl6KGNvbnRleHQsIHBvc1swXSwgcG9zWzFdLCAyLCBcIndoaXRlXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXdDaXJjbGUoY29udGV4dCwgeCwgeSwgcmFkaXVzLCBjb2xvciwgd2lkdGgpIHtcbiAgICBjb250ZXh0Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KVxuICAgIGNvbnRleHQuYXJjKHgsIHksIHJhZGl1cywgMCwgMipNYXRoLlBJLCBmYWxzZSk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHh5eihjb250ZXh0LCB4LCB5LCByYWRpdXMsIGNvbG9yKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuYXJjKHgsIHksIHJhZGl1cywgMCwgMipNYXRoLlBJLCBmYWxzZSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH1cblxuICBGbG9jay5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgbnVtQm9pZHMgPSB0aGlzLmJvaWRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpZHhCb2lkID0gMDsgaWR4Qm9pZCA8IG51bUJvaWRzOyArK2lkeEJvaWQpIHtcbiAgICAgIHRoaXMuYm9pZHNbaWR4Qm9pZF0uZHJhdyhjb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gRmxvY2s7XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9mbG9jay5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBNaWxkbyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKFwiTUlMRE9cIik7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vanMvbWlsZG8uanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==