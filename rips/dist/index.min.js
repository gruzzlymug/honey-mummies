/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = (function () {
  Boid.prototype.numBoids = 0;
  Boid.prototype.pos = [];
  Boid.prototype.vel = [];
  Boid.prototype.neighbors = [];
  Boid.prototype.centroid = [];

  function Boid(pos, vel) {
    this.id = Boid.prototype.numBoids++;
    Boid.prototype.pos[this.id] = pos;
    Boid.prototype.vel[this.id] = vel;
    Boid.prototype.neighbors[this.id] = [];
  }

  Boid.prototype.constructor = Boid

  Boid.prototype.separate = function () {
    var neighbors = Boid.prototype.neighbors[this.id]
    var numNeighbors = neighbors.length;
    var av = [0, 0];
    var bp = Boid.prototype.pos[this.id];
    var threshold = 100*100;
    for (var i = 0; i < numNeighbors; ++i) {
      var nid = neighbors[i];
      var np = Boid.prototype.pos[nid];

      var d = [0, 0];
      d[0] = bp[0] - np[0];
      d[1] = bp[1] - np[1];
      var ds = d[0]*d[0] + d[1]*d[1];
      if (ds < threshold) {
        // NOTE add factor to prevent divide by 0
        ds += 0.1;
        var factor = threshold / ds;
        av[0] += d[0] * factor;
        av[1] += d[1] * factor;
      }
    }
    av = normalize(av);

    return av;
  }

  Boid.prototype.cohere = function () {
    var cv = [0, 0];
    if (Boid.prototype.neighbors[this.id].length === 0) {
      return cv;
    }

    goal = Boid.prototype.centroid[this.id];
    var bp = Boid.prototype.pos[this.id];
    cv[0] = goal[0] - bp[0];
    cv[1] = goal[1] - bp[1];
    return cv;
  }

  function clamper() {

  }

  Boid.prototype.update = function (dt) {
    // velocity modifiers
    var sv = this.separate();
    var sf = 0.0;

    var cv = this.cohere();
    // let dist2 = dot(cv, cv);
    // if (dist2 < 4 || dist2 > 120) {
    //   cv = [0, 0];
    // }
    var cf = 0.0;

    //----
    let bvc = 0.99999999;
    var bv = Boid.prototype.vel[this.id];

    var vm = [0, 0];
    vm[0] = sf*sv[0] + cf*cv[0] + bvc*bv[0];
    vm[1] = sf*sv[1] + cf*cv[1] + bvc*bv[1];

    let vl = Math.sqrt(dot(vm, vm));
    if (vl > 4) {
      vm = normalize(vm);
      vm[0] *= 4;
      vm[1] *= 4;
    }

    Boid.prototype.vel[this.id] = vm;
  }

  Boid.prototype.move = function (dt) {
    let vc = 1;
    Boid.prototype.pos[this.id][0] += (vc * Boid.prototype.vel[this.id][0]);
    Boid.prototype.pos[this.id][1] += (vc * Boid.prototype.vel[this.id][1]);

    // keep boid within limits
    var width = 200; //context.canvas.width - 1;
    var height = 200; //context.canvas.height - 1;

    var bx = Boid.prototype.pos[this.id][0];
    if (bx >= width) {
      Boid.prototype.pos[this.id][0] = 0; // bx - width;
    } else if (bx < 0) {
      Boid.prototype.pos[this.id][0] = width; // bx + width;
    }

    var by = Boid.prototype.pos[this.id][1];
    if (by >= height) {
      Boid.prototype.pos[this.id][1] = 0; // by - height;
    } else if (by < 0) {
      Boid.prototype.pos[this.id][1] = height; // by + height;
    }
  }

  Boid.prototype.draw = function (context) {
    this.ctx = context;

    var x = Boid.prototype.pos[this.id][0];
    var y = Boid.prototype.pos[this.id][1];

    context.beginPath();
    context.fillStyle = "blue";
    if (this.id != 0) {
      context.fillStyle = "yellow";
    }
    context.arc(x, y, 4, 0, 2*Math.PI, false);
    context.fill();
  }

  function sayIt() {
    console.log("HEEBEE JEEBEE");
  }

  Boid.prototype.blah = function () {
    sayIt();
  }

  return Boid;
})();


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mildo__ = __webpack_require__(5);
// import Boid from './Boid'
var Grid = __webpack_require__(3);
var Flock = __webpack_require__(4);


//--[ step ]--------------------------------------------------------------
function step(timestamp) {
  let frameTimeMs = timestamp - last;
  last = timestamp;
  // console.log(frameTimeMs);

  // frames per second
  let elapsedTime = (timestamp - startTime) / 1000,
  result = Math.floor((frame / elapsedTime));
  if (elapsedTime > 1) {
    startTime = timestamp;
    frame = 0;
  }
  if (frame % 10 == 0) {
    let fpsText = result.toString();
    // console.log(fpsText);
  }
  ++frame;

  context.fillStyle = "black";
  context.fillRect(0, 0, canvas.width, canvas.height);

  if (frame % 3 === 0) {
    f.update(timestamp);
  }
  f.spawn(0);
  f.debugDraw(context);
  f.draw(context);

  window.requestAnimationFrame(step);
}

//------------------------------------------------------------------------
var last = performance.now();
var startTime = last;
var frame = 0;

let m = new __WEBPACK_IMPORTED_MODULE_0__mildo__["a" /* default */]();

let ww = window.innerWidth;
let wh = window.innerHeight;
var canvas = document.getElementById('field');
var context = canvas.getContext('2d');
context.canvas.width = ww;
context.canvas.height = wh;

let g = new Grid(ww, wh, 100);
let f = new Flock(g);
f.createBoids(100);
//f.createSource(ww / 2, wh / 2);
f.createSource(25, 25);

window.requestAnimationFrame(step);


/***/ }),
/* 2 */
/***/ (function(module, exports) {

//
// Simulation Math Utilities
//
// TODO FIX
// TODO this is just throwing everything into the
//      global namespace...
module.exports = (function () {
  this.nearlyZero = 0.00001;

  this.normalize = function (v) {
    let lv = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
    if (Math.abs(lv) > nearlyZero) {
      v[0] /= lv;
      v[1] /= lv;
    }
    return v;
  }

  this.dot = function(v1, v2) {
    return v1[0]*v2[0] + v1[1]*v2[1]
  }

  this.buildRotationMatrix = function(degrees) {
    var radians = degrees * Math.PI / 180.0;
    var matrix = [
      [Math.cos(radians), -Math.sin(radians)],
      [Math.sin(radians), Math.cos(radians)],
    ];
    return matrix;
  }

  this.rotate = function(v, m) {
    var x = m[0][0]*v[0] + m[0][1]*v[1]
    var y = m[1][0]*v[0] + m[1][1]*v[1]
    return [x, y];
  }

  this.randomInRange = function(min, max, wantInt) {
    var max = (max === 0 || max) ? max : 1,
        min = min || 0,
        gen = min + (max - min) * Math.random();

    return (wantInt) ? Math.round(gen) : gen;
  }

  return {
    // normalize: normalize,
    dot: dot,
    buildRotationMatrix: buildRotationMatrix,
    rotate: rotate,
    randomInRange: randomInRange
  };
})();


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var Boid = __webpack_require__(0);

module.exports = (function () {
  // move to reset fn?
  Grid.prototype.width = 0;
  Grid.prototype.height = 0;
  Grid.prototype.cx = 0;
  Grid.prototype.cy = 0;
  Grid.prototype.minCellDim = 0;
  Grid.prototype.field = [];

  function Grid(width, height, minCellDim) {
    // x
    Grid.prototype.width = width;
    Grid.prototype.cx = Math.ceil(width / minCellDim);

    // y
    Grid.prototype.height = height;
    Grid.prototype.cy = Math.ceil(height / minCellDim);

    Grid.prototype.minCellDim = minCellDim;

    for (var x = 0; x < Grid.prototype.cx; ++x) {
      Grid.prototype.field[x] = []
      for (var y = 0; y < Grid.prototype.cy; ++y) {
        Grid.prototype.field[x].push([]);
      }
    }

    var endit = 0;
  }

  Grid.prototype.constructor = Grid;

  Grid.prototype.add = function(positions) {
    // clear the grid
    for (var x = 0; x < Grid.prototype.field.length; ++x) {
      for (var y = 0; y < Grid.prototype.field[0].length; ++y) {
        Grid.prototype.field[x][y] = []
      }
    }

    // do the adding
    var numPositions = positions.length;
    for (var idxPos = 0; idxPos < numPositions; ++idxPos) {
      var bp = positions[idxPos];
      var xc = Math.floor(bp[0] / Grid.prototype.minCellDim);
      var yc = Math.floor(bp[1] / Grid.prototype.minCellDim);
      if (Grid.prototype.field[xc] === undefined) {
        var break_here = true;
      }
      Grid.prototype.field[xc][yc].push(idxPos);
      // color boids based on position
      // Boid.prototype.hue[idxPos] = ((yc + xc) % 2) == 0 ? "blue" : "green"
    }

    // save the positions for the queries
    Grid.prototype.positions = positions;
  }

  Grid.prototype.query = function(mx, my) {
    var xc = Math.floor(mx / Grid.prototype.minCellDim);
    var yc = Math.floor(my / Grid.prototype.minCellDim);

    var selectedID = null;
    var minToBoidSqr = Grid.prototype.minCellDim * Grid.prototype.minCellDim;
    var candidates = Grid.prototype.field[xc][yc];
    var numCandidates = candidates.length;
    for (var idxCandidate = 0; idxCandidate < numCandidates; ++idxCandidate) {
      var candidateID = candidates[idxCandidate];
      var pos = Grid.prototype.positions[candidateID];
      var dx = pos[0] - mx;
      var dy = pos[1] - my;
      var toBoidSqr = dx*dx + dy*dy;
      if (toBoidSqr < 121 && toBoidSqr < minToBoidSqr) {
        selectedID = candidateID;
        minToBoidSqr = toBoidSqr;
      }
    }

    return selectedID;
  }

  Grid.prototype.findNeighbors = function(threshold, maxNeighbors) {
    var scaleFactor = 1000;
    var numBoids = Boid.prototype.numBoids;

    for (var idxBoid = 0; idxBoid < numBoids; ++idxBoid) {
      var bp = Boid.prototype.pos[idxBoid];
      var qx = bp[0];
      var qy = bp[1];

      var x0 = Math.floor((qx - threshold) / Grid.prototype.minCellDim);
      x0 = Math.max(0, x0);
      var x1 = Math.floor((qx + threshold) / Grid.prototype.minCellDim);
      x1 = Math.min(Grid.prototype.field.length - 1, x1);
      var y0 = Math.floor((qy - threshold) / Grid.prototype.minCellDim);
      y0 = Math.max(0, y0);
      var y1 = Math.floor((qy + threshold) / Grid.prototype.minCellDim);
      y1 = Math.min(Grid.prototype.field[0].length - 1, y1);

      var candidates = [];
      for (var x = x0; x <= x1; ++x) {
        for (var y = y0; y <= y1; ++y) {
          candidates.push.apply(candidates, Grid.prototype.field[x][y]);
        }
      }

      var neighbors = [];
      var tsqr = threshold * threshold;
      var numCandidates = candidates.length;
      for (var idxCandidate = 0; idxCandidate < numCandidates; ++idxCandidate) {
        var candidateID = candidates[idxCandidate];
        var cpos = Grid.prototype.positions[candidateID];
        var dx = cpos[0] - qx;
        var dy = cpos[1] - qy;
        var dsqr = dx*dx + dy*dy;
        if (dsqr <= tsqr && dsqr > nearlyZero) {
          neighbors.push(Math.ceil(dsqr) * scaleFactor + candidateID);
        }
      }
      // sort neighbors to get the closest
      neighbors = neighbors.sort(function(a,b){return a-b});
      neighbors = neighbors.slice(0, maxNeighbors);
      // strip off the position info to leave the IDs
      Boid.prototype.neighbors[idxBoid] = neighbors.map(function(x){return x % scaleFactor});
    }
  }

  return Grid;
})();


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__(2);
var Boid = __webpack_require__(0);

module.exports = (function () {
  Flock.prototype.sources = [];

  function Flock(grid) {
    this.grid = grid;
    this.numActive = 0;
    this.boids = [];
    this.neighborDist = 75;
    this.maxNeighbors = 10;
  }

  Flock.prototype.constructor = Flock

  function createBoid() {
    var numSources = Flock.prototype.sources.length;
    var idxSource = randomInRange(0, numSources - 1, true);
    var src = Flock.prototype.sources[idxSource];
    var p = [src[0], src[1]];
    p[0] += Math.random() * 6 - 3;
    p[1] += Math.random() * 6 - 3;

    // set velocity (aka heading)
    var v = [(Math.random() - 0.5), (Math.random() - 0.5)];
    v = normalize(v);

    return new Boid(p, v);
  }

  Flock.prototype.createSource = function (x, y) {
    let nextSourceIdx = Flock.prototype.sources.length;
    Flock.prototype.sources[nextSourceIdx] = [x, y];
  }

  Flock.prototype.createBoids = function (numBoids) {
    this.numDesired = numBoids;
  }

  Flock.prototype.spawn = function (dt) {
    var numBoids = this.boids.length;
    this.numActive = Math.min(numBoids, this.numActive);
    if (this.numActive < this.numDesired) {
      ++this.numActive;
      if (this.numActive > numBoids) {
        this.boids[numBoids] = createBoid();
      }
    }
  }

  Flock.prototype.update = function (dt) {
    for (let idxBoid = 0; idxBoid < this.numActive; ++idxBoid) {
      this.boids[idxBoid].update(dt);
      this.boids[idxBoid].move(dt);
    }

    this.grid.add(Boid.prototype.pos);
    this.grid.findNeighbors(this.neighborDist, this.maxNeighbors);

    for (let idxBoid = 0; idxBoid < this.numActive; ++idxBoid) {
      Boid.prototype.centroid[idxBoid] = findGroupCentroid(idxBoid);
    }
  }

  function findGroupCentroid(boidId) {
    var neighbors = Boid.prototype.neighbors[boidId]
    var numNeighbors = neighbors.length;
    var bp = Boid.prototype.pos[boidId];
    var goal = [bp[0], bp[1]];
    for (var i = 0; i < numNeighbors; ++i) {
      var nid = neighbors[i];
      var np = Boid.prototype.pos[nid];

      goal[0] += np[0];
      goal[1] += np[1];
    }
    goal[0] /= numNeighbors+1;
    goal[1] /= numNeighbors+1;

    return goal;
  }

  Flock.prototype.debugDraw = function (context) {
    let numBoids = this.boids.length;
    let specialBoidId = 0;
    let skipRegularBoids = true;

    for (let idxBoid = 0; idxBoid < numBoids; ++idxBoid) {
      if (skipRegularBoids && idxBoid != specialBoidId) {
        continue;
      }

      var bp = Boid.prototype.pos[idxBoid];

      // draw neighborDist range
      drawCircle(context, bp[0], bp[1], this.neighborDist, 'darkgray', 0.5);

      var neighbors = Boid.prototype.neighbors[idxBoid];
      var numNeighbors = neighbors.length;
      if (numNeighbors > 0) {
        context.strokeStyle = "red"; //"hsla(" + this.hue + ",100%,50%,1)";
        context.lineWidth = 0.5;
        context.beginPath();
        let pos = Boid.prototype.centroid[idxBoid];
        for (var i = 0; i < numNeighbors; ++i) {
          context.moveTo(pos[0], pos[1]);
          var nid = neighbors[i];
          var np = Boid.prototype.pos[nid];
          context.lineTo(np[0], np[1]);
          context.stroke();
        }

        context.moveTo(pos[0], pos[1]);
        context.lineTo(bp[0], bp[1]);
        context.stroke();

        xyz(context, pos[0], pos[1], 2, "white");
      }
    }
  }

  function drawCircle(context, x, y, radius, color, width) {
    context.moveTo(x + radius, y)
    context.arc(x, y, radius, 0, 2*Math.PI, false);
    context.lineWidth = width;
    context.strokeStyle = color;
    context.stroke();
  }

  function xyz(context, x, y, radius, color) {
    context.beginPath();
    context.fillStyle = color;
    context.arc(x, y, radius, 0, 2*Math.PI, false);
    context.fill();
  }

  Flock.prototype.draw = function(context) {
    var numBoids = this.boids.length;
    for (var idxBoid = 0; idxBoid < numBoids; ++idxBoid) {
      this.boids[idxBoid].draw(context);
    }
  }

  return Flock;
})();


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class Mildo {
  constructor() {
    console.log("MILDO");
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Mildo;



/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZTc5MDJmYTZmZjY0ZWZiNDYzMjAiLCJ3ZWJwYWNrOi8vLy4vanMvQm9pZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9zbXUuanMiLCJ3ZWJwYWNrOi8vLy4vanMvZ3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9mbG9jay5qcyIsIndlYnBhY2s6Ly8vLi9qcy9taWxkby5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLG9CQUFvQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7OztBQ2pKRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQSIsImZpbGUiOiJpbmRleC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBlNzkwMmZhNmZmNjRlZmI0NjMyMCIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgQm9pZC5wcm90b3R5cGUubnVtQm9pZHMgPSAwO1xuICBCb2lkLnByb3RvdHlwZS5wb3MgPSBbXTtcbiAgQm9pZC5wcm90b3R5cGUudmVsID0gW107XG4gIEJvaWQucHJvdG90eXBlLm5laWdoYm9ycyA9IFtdO1xuICBCb2lkLnByb3RvdHlwZS5jZW50cm9pZCA9IFtdO1xuXG4gIGZ1bmN0aW9uIEJvaWQocG9zLCB2ZWwpIHtcbiAgICB0aGlzLmlkID0gQm9pZC5wcm90b3R5cGUubnVtQm9pZHMrKztcbiAgICBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF0gPSBwb3M7XG4gICAgQm9pZC5wcm90b3R5cGUudmVsW3RoaXMuaWRdID0gdmVsO1xuICAgIEJvaWQucHJvdG90eXBlLm5laWdoYm9yc1t0aGlzLmlkXSA9IFtdO1xuICB9XG5cbiAgQm9pZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb2lkXG5cbiAgQm9pZC5wcm90b3R5cGUuc2VwYXJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5laWdoYm9ycyA9IEJvaWQucHJvdG90eXBlLm5laWdoYm9yc1t0aGlzLmlkXVxuICAgIHZhciBudW1OZWlnaGJvcnMgPSBuZWlnaGJvcnMubGVuZ3RoO1xuICAgIHZhciBhdiA9IFswLCAwXTtcbiAgICB2YXIgYnAgPSBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF07XG4gICAgdmFyIHRocmVzaG9sZCA9IDEwMCoxMDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1OZWlnaGJvcnM7ICsraSkge1xuICAgICAgdmFyIG5pZCA9IG5laWdoYm9yc1tpXTtcbiAgICAgIHZhciBucCA9IEJvaWQucHJvdG90eXBlLnBvc1tuaWRdO1xuXG4gICAgICB2YXIgZCA9IFswLCAwXTtcbiAgICAgIGRbMF0gPSBicFswXSAtIG5wWzBdO1xuICAgICAgZFsxXSA9IGJwWzFdIC0gbnBbMV07XG4gICAgICB2YXIgZHMgPSBkWzBdKmRbMF0gKyBkWzFdKmRbMV07XG4gICAgICBpZiAoZHMgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgLy8gTk9URSBhZGQgZmFjdG9yIHRvIHByZXZlbnQgZGl2aWRlIGJ5IDBcbiAgICAgICAgZHMgKz0gMC4xO1xuICAgICAgICB2YXIgZmFjdG9yID0gdGhyZXNob2xkIC8gZHM7XG4gICAgICAgIGF2WzBdICs9IGRbMF0gKiBmYWN0b3I7XG4gICAgICAgIGF2WzFdICs9IGRbMV0gKiBmYWN0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIGF2ID0gbm9ybWFsaXplKGF2KTtcblxuICAgIHJldHVybiBhdjtcbiAgfVxuXG4gIEJvaWQucHJvdG90eXBlLmNvaGVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3YgPSBbMCwgMF07XG4gICAgaWYgKEJvaWQucHJvdG90eXBlLm5laWdoYm9yc1t0aGlzLmlkXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjdjtcbiAgICB9XG5cbiAgICBnb2FsID0gQm9pZC5wcm90b3R5cGUuY2VudHJvaWRbdGhpcy5pZF07XG4gICAgdmFyIGJwID0gQm9pZC5wcm90b3R5cGUucG9zW3RoaXMuaWRdO1xuICAgIGN2WzBdID0gZ29hbFswXSAtIGJwWzBdO1xuICAgIGN2WzFdID0gZ29hbFsxXSAtIGJwWzFdO1xuICAgIHJldHVybiBjdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYW1wZXIoKSB7XG5cbiAgfVxuXG4gIEJvaWQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkdCkge1xuICAgIC8vIHZlbG9jaXR5IG1vZGlmaWVyc1xuICAgIHZhciBzdiA9IHRoaXMuc2VwYXJhdGUoKTtcbiAgICB2YXIgc2YgPSAwLjA7XG5cbiAgICB2YXIgY3YgPSB0aGlzLmNvaGVyZSgpO1xuICAgIC8vIGxldCBkaXN0MiA9IGRvdChjdiwgY3YpO1xuICAgIC8vIGlmIChkaXN0MiA8IDQgfHwgZGlzdDIgPiAxMjApIHtcbiAgICAvLyAgIGN2ID0gWzAsIDBdO1xuICAgIC8vIH1cbiAgICB2YXIgY2YgPSAwLjA7XG5cbiAgICAvLy0tLS1cbiAgICBsZXQgYnZjID0gMC45OTk5OTk5OTtcbiAgICB2YXIgYnYgPSBCb2lkLnByb3RvdHlwZS52ZWxbdGhpcy5pZF07XG5cbiAgICB2YXIgdm0gPSBbMCwgMF07XG4gICAgdm1bMF0gPSBzZipzdlswXSArIGNmKmN2WzBdICsgYnZjKmJ2WzBdO1xuICAgIHZtWzFdID0gc2Yqc3ZbMV0gKyBjZipjdlsxXSArIGJ2YypidlsxXTtcblxuICAgIGxldCB2bCA9IE1hdGguc3FydChkb3Qodm0sIHZtKSk7XG4gICAgaWYgKHZsID4gNCkge1xuICAgICAgdm0gPSBub3JtYWxpemUodm0pO1xuICAgICAgdm1bMF0gKj0gNDtcbiAgICAgIHZtWzFdICo9IDQ7XG4gICAgfVxuXG4gICAgQm9pZC5wcm90b3R5cGUudmVsW3RoaXMuaWRdID0gdm07XG4gIH1cblxuICBCb2lkLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGR0KSB7XG4gICAgbGV0IHZjID0gMTtcbiAgICBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMF0gKz0gKHZjICogQm9pZC5wcm90b3R5cGUudmVsW3RoaXMuaWRdWzBdKTtcbiAgICBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMV0gKz0gKHZjICogQm9pZC5wcm90b3R5cGUudmVsW3RoaXMuaWRdWzFdKTtcblxuICAgIC8vIGtlZXAgYm9pZCB3aXRoaW4gbGltaXRzXG4gICAgdmFyIHdpZHRoID0gMjAwOyAvL2NvbnRleHQuY2FudmFzLndpZHRoIC0gMTtcbiAgICB2YXIgaGVpZ2h0ID0gMjAwOyAvL2NvbnRleHQuY2FudmFzLmhlaWdodCAtIDE7XG5cbiAgICB2YXIgYnggPSBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMF07XG4gICAgaWYgKGJ4ID49IHdpZHRoKSB7XG4gICAgICBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMF0gPSAwOyAvLyBieCAtIHdpZHRoO1xuICAgIH0gZWxzZSBpZiAoYnggPCAwKSB7XG4gICAgICBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMF0gPSB3aWR0aDsgLy8gYnggKyB3aWR0aDtcbiAgICB9XG5cbiAgICB2YXIgYnkgPSBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMV07XG4gICAgaWYgKGJ5ID49IGhlaWdodCkge1xuICAgICAgQm9pZC5wcm90b3R5cGUucG9zW3RoaXMuaWRdWzFdID0gMDsgLy8gYnkgLSBoZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChieSA8IDApIHtcbiAgICAgIEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVsxXSA9IGhlaWdodDsgLy8gYnkgKyBoZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgQm9pZC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xuXG4gICAgdmFyIHggPSBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMF07XG4gICAgdmFyIHkgPSBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMV07XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJibHVlXCI7XG4gICAgaWYgKHRoaXMuaWQgIT0gMCkge1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInllbGxvd1wiO1xuICAgIH1cbiAgICBjb250ZXh0LmFyYyh4LCB5LCA0LCAwLCAyKk1hdGguUEksIGZhbHNlKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNheUl0KCkge1xuICAgIGNvbnNvbGUubG9nKFwiSEVFQkVFIEpFRUJFRVwiKTtcbiAgfVxuXG4gIEJvaWQucHJvdG90eXBlLmJsYWggPSBmdW5jdGlvbiAoKSB7XG4gICAgc2F5SXQoKTtcbiAgfVxuXG4gIHJldHVybiBCb2lkO1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vanMvQm9pZC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBpbXBvcnQgQm9pZCBmcm9tICcuL0JvaWQnXG52YXIgR3JpZCA9IHJlcXVpcmUoJy4vZ3JpZCcpO1xudmFyIEZsb2NrID0gcmVxdWlyZSgnLi9mbG9jay5qcycpO1xuaW1wb3J0IE1pbGRvIGZyb20gJy4vbWlsZG8nO1xuXG4vLy0tWyBzdGVwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc3RlcCh0aW1lc3RhbXApIHtcbiAgbGV0IGZyYW1lVGltZU1zID0gdGltZXN0YW1wIC0gbGFzdDtcbiAgbGFzdCA9IHRpbWVzdGFtcDtcbiAgLy8gY29uc29sZS5sb2coZnJhbWVUaW1lTXMpO1xuXG4gIC8vIGZyYW1lcyBwZXIgc2Vjb25kXG4gIGxldCBlbGFwc2VkVGltZSA9ICh0aW1lc3RhbXAgLSBzdGFydFRpbWUpIC8gMTAwMCxcbiAgcmVzdWx0ID0gTWF0aC5mbG9vcigoZnJhbWUgLyBlbGFwc2VkVGltZSkpO1xuICBpZiAoZWxhcHNlZFRpbWUgPiAxKSB7XG4gICAgc3RhcnRUaW1lID0gdGltZXN0YW1wO1xuICAgIGZyYW1lID0gMDtcbiAgfVxuICBpZiAoZnJhbWUgJSAxMCA9PSAwKSB7XG4gICAgbGV0IGZwc1RleHQgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAvLyBjb25zb2xlLmxvZyhmcHNUZXh0KTtcbiAgfVxuICArK2ZyYW1lO1xuXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgaWYgKGZyYW1lICUgMyA9PT0gMCkge1xuICAgIGYudXBkYXRlKHRpbWVzdGFtcCk7XG4gIH1cbiAgZi5zcGF3bigwKTtcbiAgZi5kZWJ1Z0RyYXcoY29udGV4dCk7XG4gIGYuZHJhdyhjb250ZXh0KTtcblxuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIGxhc3QgPSBwZXJmb3JtYW5jZS5ub3coKTtcbnZhciBzdGFydFRpbWUgPSBsYXN0O1xudmFyIGZyYW1lID0gMDtcblxubGV0IG0gPSBuZXcgTWlsZG8oKTtcblxubGV0IHd3ID0gd2luZG93LmlubmVyV2lkdGg7XG5sZXQgd2ggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG52YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpZWxkJyk7XG52YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuY29udGV4dC5jYW52YXMud2lkdGggPSB3dztcbmNvbnRleHQuY2FudmFzLmhlaWdodCA9IHdoO1xuXG5sZXQgZyA9IG5ldyBHcmlkKHd3LCB3aCwgMTAwKTtcbmxldCBmID0gbmV3IEZsb2NrKGcpO1xuZi5jcmVhdGVCb2lkcygxMDApO1xuLy9mLmNyZWF0ZVNvdXJjZSh3dyAvIDIsIHdoIC8gMik7XG5mLmNyZWF0ZVNvdXJjZSgyNSwgMjUpO1xuXG53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL1xuLy8gU2ltdWxhdGlvbiBNYXRoIFV0aWxpdGllc1xuLy9cbi8vIFRPRE8gRklYXG4vLyBUT0RPIHRoaXMgaXMganVzdCB0aHJvd2luZyBldmVyeXRoaW5nIGludG8gdGhlXG4vLyAgICAgIGdsb2JhbCBuYW1lc3BhY2UuLi5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5uZWFybHlaZXJvID0gMC4wMDAwMTtcblxuICB0aGlzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgbGV0IGx2ID0gTWF0aC5zcXJ0KHZbMF0qdlswXSArIHZbMV0qdlsxXSk7XG4gICAgaWYgKE1hdGguYWJzKGx2KSA+IG5lYXJseVplcm8pIHtcbiAgICAgIHZbMF0gLz0gbHY7XG4gICAgICB2WzFdIC89IGx2O1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIHRoaXMuZG90ID0gZnVuY3Rpb24odjEsIHYyKSB7XG4gICAgcmV0dXJuIHYxWzBdKnYyWzBdICsgdjFbMV0qdjJbMV1cbiAgfVxuXG4gIHRoaXMuYnVpbGRSb3RhdGlvbk1hdHJpeCA9IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcbiAgICB2YXIgcmFkaWFucyA9IGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgIFtNYXRoLmNvcyhyYWRpYW5zKSwgLU1hdGguc2luKHJhZGlhbnMpXSxcbiAgICAgIFtNYXRoLnNpbihyYWRpYW5zKSwgTWF0aC5jb3MocmFkaWFucyldLFxuICAgIF07XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuXG4gIHRoaXMucm90YXRlID0gZnVuY3Rpb24odiwgbSkge1xuICAgIHZhciB4ID0gbVswXVswXSp2WzBdICsgbVswXVsxXSp2WzFdXG4gICAgdmFyIHkgPSBtWzFdWzBdKnZbMF0gKyBtWzFdWzFdKnZbMV1cbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG5cbiAgdGhpcy5yYW5kb21JblJhbmdlID0gZnVuY3Rpb24obWluLCBtYXgsIHdhbnRJbnQpIHtcbiAgICB2YXIgbWF4ID0gKG1heCA9PT0gMCB8fCBtYXgpID8gbWF4IDogMSxcbiAgICAgICAgbWluID0gbWluIHx8IDAsXG4gICAgICAgIGdlbiA9IG1pbiArIChtYXggLSBtaW4pICogTWF0aC5yYW5kb20oKTtcblxuICAgIHJldHVybiAod2FudEludCkgPyBNYXRoLnJvdW5kKGdlbikgOiBnZW47XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuICAgIGRvdDogZG90LFxuICAgIGJ1aWxkUm90YXRpb25NYXRyaXg6IGJ1aWxkUm90YXRpb25NYXRyaXgsXG4gICAgcm90YXRlOiByb3RhdGUsXG4gICAgcmFuZG9tSW5SYW5nZTogcmFuZG9tSW5SYW5nZVxuICB9O1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vanMvc211LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBCb2lkID0gcmVxdWlyZSgnLi9Cb2lkLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gbW92ZSB0byByZXNldCBmbj9cbiAgR3JpZC5wcm90b3R5cGUud2lkdGggPSAwO1xuICBHcmlkLnByb3RvdHlwZS5oZWlnaHQgPSAwO1xuICBHcmlkLnByb3RvdHlwZS5jeCA9IDA7XG4gIEdyaWQucHJvdG90eXBlLmN5ID0gMDtcbiAgR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSA9IDA7XG4gIEdyaWQucHJvdG90eXBlLmZpZWxkID0gW107XG5cbiAgZnVuY3Rpb24gR3JpZCh3aWR0aCwgaGVpZ2h0LCBtaW5DZWxsRGltKSB7XG4gICAgLy8geFxuICAgIEdyaWQucHJvdG90eXBlLndpZHRoID0gd2lkdGg7XG4gICAgR3JpZC5wcm90b3R5cGUuY3ggPSBNYXRoLmNlaWwod2lkdGggLyBtaW5DZWxsRGltKTtcblxuICAgIC8vIHlcbiAgICBHcmlkLnByb3RvdHlwZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgR3JpZC5wcm90b3R5cGUuY3kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gbWluQ2VsbERpbSk7XG5cbiAgICBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltID0gbWluQ2VsbERpbTtcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgR3JpZC5wcm90b3R5cGUuY3g7ICsreCkge1xuICAgICAgR3JpZC5wcm90b3R5cGUuZmllbGRbeF0gPSBbXVxuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBHcmlkLnByb3RvdHlwZS5jeTsgKyt5KSB7XG4gICAgICAgIEdyaWQucHJvdG90eXBlLmZpZWxkW3hdLnB1c2goW10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlbmRpdCA9IDA7XG4gIH1cblxuICBHcmlkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyaWQ7XG5cbiAgR3JpZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocG9zaXRpb25zKSB7XG4gICAgLy8gY2xlYXIgdGhlIGdyaWRcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IEdyaWQucHJvdG90eXBlLmZpZWxkLmxlbmd0aDsgKyt4KSB7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IEdyaWQucHJvdG90eXBlLmZpZWxkWzBdLmxlbmd0aDsgKyt5KSB7XG4gICAgICAgIEdyaWQucHJvdG90eXBlLmZpZWxkW3hdW3ldID0gW11cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkbyB0aGUgYWRkaW5nXG4gICAgdmFyIG51bVBvc2l0aW9ucyA9IHBvc2l0aW9ucy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaWR4UG9zID0gMDsgaWR4UG9zIDwgbnVtUG9zaXRpb25zOyArK2lkeFBvcykge1xuICAgICAgdmFyIGJwID0gcG9zaXRpb25zW2lkeFBvc107XG4gICAgICB2YXIgeGMgPSBNYXRoLmZsb29yKGJwWzBdIC8gR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSk7XG4gICAgICB2YXIgeWMgPSBNYXRoLmZsb29yKGJwWzFdIC8gR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSk7XG4gICAgICBpZiAoR3JpZC5wcm90b3R5cGUuZmllbGRbeGNdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGJyZWFrX2hlcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgR3JpZC5wcm90b3R5cGUuZmllbGRbeGNdW3ljXS5wdXNoKGlkeFBvcyk7XG4gICAgICAvLyBjb2xvciBib2lkcyBiYXNlZCBvbiBwb3NpdGlvblxuICAgICAgLy8gQm9pZC5wcm90b3R5cGUuaHVlW2lkeFBvc10gPSAoKHljICsgeGMpICUgMikgPT0gMCA/IFwiYmx1ZVwiIDogXCJncmVlblwiXG4gICAgfVxuXG4gICAgLy8gc2F2ZSB0aGUgcG9zaXRpb25zIGZvciB0aGUgcXVlcmllc1xuICAgIEdyaWQucHJvdG90eXBlLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgfVxuXG4gIEdyaWQucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24obXgsIG15KSB7XG4gICAgdmFyIHhjID0gTWF0aC5mbG9vcihteCAvIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0pO1xuICAgIHZhciB5YyA9IE1hdGguZmxvb3IobXkgLyBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltKTtcblxuICAgIHZhciBzZWxlY3RlZElEID0gbnVsbDtcbiAgICB2YXIgbWluVG9Cb2lkU3FyID0gR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSAqIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW07XG4gICAgdmFyIGNhbmRpZGF0ZXMgPSBHcmlkLnByb3RvdHlwZS5maWVsZFt4Y11beWNdO1xuICAgIHZhciBudW1DYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaWR4Q2FuZGlkYXRlID0gMDsgaWR4Q2FuZGlkYXRlIDwgbnVtQ2FuZGlkYXRlczsgKytpZHhDYW5kaWRhdGUpIHtcbiAgICAgIHZhciBjYW5kaWRhdGVJRCA9IGNhbmRpZGF0ZXNbaWR4Q2FuZGlkYXRlXTtcbiAgICAgIHZhciBwb3MgPSBHcmlkLnByb3RvdHlwZS5wb3NpdGlvbnNbY2FuZGlkYXRlSURdO1xuICAgICAgdmFyIGR4ID0gcG9zWzBdIC0gbXg7XG4gICAgICB2YXIgZHkgPSBwb3NbMV0gLSBteTtcbiAgICAgIHZhciB0b0JvaWRTcXIgPSBkeCpkeCArIGR5KmR5O1xuICAgICAgaWYgKHRvQm9pZFNxciA8IDEyMSAmJiB0b0JvaWRTcXIgPCBtaW5Ub0JvaWRTcXIpIHtcbiAgICAgICAgc2VsZWN0ZWRJRCA9IGNhbmRpZGF0ZUlEO1xuICAgICAgICBtaW5Ub0JvaWRTcXIgPSB0b0JvaWRTcXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGVkSUQ7XG4gIH1cblxuICBHcmlkLnByb3RvdHlwZS5maW5kTmVpZ2hib3JzID0gZnVuY3Rpb24odGhyZXNob2xkLCBtYXhOZWlnaGJvcnMpIHtcbiAgICB2YXIgc2NhbGVGYWN0b3IgPSAxMDAwO1xuICAgIHZhciBudW1Cb2lkcyA9IEJvaWQucHJvdG90eXBlLm51bUJvaWRzO1xuXG4gICAgZm9yICh2YXIgaWR4Qm9pZCA9IDA7IGlkeEJvaWQgPCBudW1Cb2lkczsgKytpZHhCb2lkKSB7XG4gICAgICB2YXIgYnAgPSBCb2lkLnByb3RvdHlwZS5wb3NbaWR4Qm9pZF07XG4gICAgICB2YXIgcXggPSBicFswXTtcbiAgICAgIHZhciBxeSA9IGJwWzFdO1xuXG4gICAgICB2YXIgeDAgPSBNYXRoLmZsb29yKChxeCAtIHRocmVzaG9sZCkgLyBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltKTtcbiAgICAgIHgwID0gTWF0aC5tYXgoMCwgeDApO1xuICAgICAgdmFyIHgxID0gTWF0aC5mbG9vcigocXggKyB0aHJlc2hvbGQpIC8gR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSk7XG4gICAgICB4MSA9IE1hdGgubWluKEdyaWQucHJvdG90eXBlLmZpZWxkLmxlbmd0aCAtIDEsIHgxKTtcbiAgICAgIHZhciB5MCA9IE1hdGguZmxvb3IoKHF5IC0gdGhyZXNob2xkKSAvIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0pO1xuICAgICAgeTAgPSBNYXRoLm1heCgwLCB5MCk7XG4gICAgICB2YXIgeTEgPSBNYXRoLmZsb29yKChxeSArIHRocmVzaG9sZCkgLyBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltKTtcbiAgICAgIHkxID0gTWF0aC5taW4oR3JpZC5wcm90b3R5cGUuZmllbGRbMF0ubGVuZ3RoIC0gMSwgeTEpO1xuXG4gICAgICB2YXIgY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgeCA9IHgwOyB4IDw9IHgxOyArK3gpIHtcbiAgICAgICAgZm9yICh2YXIgeSA9IHkwOyB5IDw9IHkxOyArK3kpIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2guYXBwbHkoY2FuZGlkYXRlcywgR3JpZC5wcm90b3R5cGUuZmllbGRbeF1beV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvcnMgPSBbXTtcbiAgICAgIHZhciB0c3FyID0gdGhyZXNob2xkICogdGhyZXNob2xkO1xuICAgICAgdmFyIG51bUNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGlkeENhbmRpZGF0ZSA9IDA7IGlkeENhbmRpZGF0ZSA8IG51bUNhbmRpZGF0ZXM7ICsraWR4Q2FuZGlkYXRlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGVJRCA9IGNhbmRpZGF0ZXNbaWR4Q2FuZGlkYXRlXTtcbiAgICAgICAgdmFyIGNwb3MgPSBHcmlkLnByb3RvdHlwZS5wb3NpdGlvbnNbY2FuZGlkYXRlSURdO1xuICAgICAgICB2YXIgZHggPSBjcG9zWzBdIC0gcXg7XG4gICAgICAgIHZhciBkeSA9IGNwb3NbMV0gLSBxeTtcbiAgICAgICAgdmFyIGRzcXIgPSBkeCpkeCArIGR5KmR5O1xuICAgICAgICBpZiAoZHNxciA8PSB0c3FyICYmIGRzcXIgPiBuZWFybHlaZXJvKSB7XG4gICAgICAgICAgbmVpZ2hib3JzLnB1c2goTWF0aC5jZWlsKGRzcXIpICogc2NhbGVGYWN0b3IgKyBjYW5kaWRhdGVJRCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHNvcnQgbmVpZ2hib3JzIHRvIGdldCB0aGUgY2xvc2VzdFxuICAgICAgbmVpZ2hib3JzID0gbmVpZ2hib3JzLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS1ifSk7XG4gICAgICBuZWlnaGJvcnMgPSBuZWlnaGJvcnMuc2xpY2UoMCwgbWF4TmVpZ2hib3JzKTtcbiAgICAgIC8vIHN0cmlwIG9mZiB0aGUgcG9zaXRpb24gaW5mbyB0byBsZWF2ZSB0aGUgSURzXG4gICAgICBCb2lkLnByb3RvdHlwZS5uZWlnaGJvcnNbaWR4Qm9pZF0gPSBuZWlnaGJvcnMubWFwKGZ1bmN0aW9uKHgpe3JldHVybiB4ICUgc2NhbGVGYWN0b3J9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gR3JpZDtcbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL2dyaWQuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi9zbXUuanMnKTtcbnZhciBCb2lkID0gcmVxdWlyZSgnLi9Cb2lkLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgRmxvY2sucHJvdG90eXBlLnNvdXJjZXMgPSBbXTtcblxuICBmdW5jdGlvbiBGbG9jayhncmlkKSB7XG4gICAgdGhpcy5ncmlkID0gZ3JpZDtcbiAgICB0aGlzLm51bUFjdGl2ZSA9IDA7XG4gICAgdGhpcy5ib2lkcyA9IFtdO1xuICAgIHRoaXMubmVpZ2hib3JEaXN0ID0gNzU7XG4gICAgdGhpcy5tYXhOZWlnaGJvcnMgPSAxMDtcbiAgfVxuXG4gIEZsb2NrLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZsb2NrXG5cbiAgZnVuY3Rpb24gY3JlYXRlQm9pZCgpIHtcbiAgICB2YXIgbnVtU291cmNlcyA9IEZsb2NrLnByb3RvdHlwZS5zb3VyY2VzLmxlbmd0aDtcbiAgICB2YXIgaWR4U291cmNlID0gcmFuZG9tSW5SYW5nZSgwLCBudW1Tb3VyY2VzIC0gMSwgdHJ1ZSk7XG4gICAgdmFyIHNyYyA9IEZsb2NrLnByb3RvdHlwZS5zb3VyY2VzW2lkeFNvdXJjZV07XG4gICAgdmFyIHAgPSBbc3JjWzBdLCBzcmNbMV1dO1xuICAgIHBbMF0gKz0gTWF0aC5yYW5kb20oKSAqIDYgLSAzO1xuICAgIHBbMV0gKz0gTWF0aC5yYW5kb20oKSAqIDYgLSAzO1xuXG4gICAgLy8gc2V0IHZlbG9jaXR5IChha2EgaGVhZGluZylcbiAgICB2YXIgdiA9IFsoTWF0aC5yYW5kb20oKSAtIDAuNSksIChNYXRoLnJhbmRvbSgpIC0gMC41KV07XG4gICAgdiA9IG5vcm1hbGl6ZSh2KTtcblxuICAgIHJldHVybiBuZXcgQm9pZChwLCB2KTtcbiAgfVxuXG4gIEZsb2NrLnByb3RvdHlwZS5jcmVhdGVTb3VyY2UgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGxldCBuZXh0U291cmNlSWR4ID0gRmxvY2sucHJvdG90eXBlLnNvdXJjZXMubGVuZ3RoO1xuICAgIEZsb2NrLnByb3RvdHlwZS5zb3VyY2VzW25leHRTb3VyY2VJZHhdID0gW3gsIHldO1xuICB9XG5cbiAgRmxvY2sucHJvdG90eXBlLmNyZWF0ZUJvaWRzID0gZnVuY3Rpb24gKG51bUJvaWRzKSB7XG4gICAgdGhpcy5udW1EZXNpcmVkID0gbnVtQm9pZHM7XG4gIH1cblxuICBGbG9jay5wcm90b3R5cGUuc3Bhd24gPSBmdW5jdGlvbiAoZHQpIHtcbiAgICB2YXIgbnVtQm9pZHMgPSB0aGlzLmJvaWRzLmxlbmd0aDtcbiAgICB0aGlzLm51bUFjdGl2ZSA9IE1hdGgubWluKG51bUJvaWRzLCB0aGlzLm51bUFjdGl2ZSk7XG4gICAgaWYgKHRoaXMubnVtQWN0aXZlIDwgdGhpcy5udW1EZXNpcmVkKSB7XG4gICAgICArK3RoaXMubnVtQWN0aXZlO1xuICAgICAgaWYgKHRoaXMubnVtQWN0aXZlID4gbnVtQm9pZHMpIHtcbiAgICAgICAgdGhpcy5ib2lkc1tudW1Cb2lkc10gPSBjcmVhdGVCb2lkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgRmxvY2sucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkdCkge1xuICAgIGZvciAobGV0IGlkeEJvaWQgPSAwOyBpZHhCb2lkIDwgdGhpcy5udW1BY3RpdmU7ICsraWR4Qm9pZCkge1xuICAgICAgdGhpcy5ib2lkc1tpZHhCb2lkXS51cGRhdGUoZHQpO1xuICAgICAgdGhpcy5ib2lkc1tpZHhCb2lkXS5tb3ZlKGR0KTtcbiAgICB9XG5cbiAgICB0aGlzLmdyaWQuYWRkKEJvaWQucHJvdG90eXBlLnBvcyk7XG4gICAgdGhpcy5ncmlkLmZpbmROZWlnaGJvcnModGhpcy5uZWlnaGJvckRpc3QsIHRoaXMubWF4TmVpZ2hib3JzKTtcblxuICAgIGZvciAobGV0IGlkeEJvaWQgPSAwOyBpZHhCb2lkIDwgdGhpcy5udW1BY3RpdmU7ICsraWR4Qm9pZCkge1xuICAgICAgQm9pZC5wcm90b3R5cGUuY2VudHJvaWRbaWR4Qm9pZF0gPSBmaW5kR3JvdXBDZW50cm9pZChpZHhCb2lkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kR3JvdXBDZW50cm9pZChib2lkSWQpIHtcbiAgICB2YXIgbmVpZ2hib3JzID0gQm9pZC5wcm90b3R5cGUubmVpZ2hib3JzW2JvaWRJZF1cbiAgICB2YXIgbnVtTmVpZ2hib3JzID0gbmVpZ2hib3JzLmxlbmd0aDtcbiAgICB2YXIgYnAgPSBCb2lkLnByb3RvdHlwZS5wb3NbYm9pZElkXTtcbiAgICB2YXIgZ29hbCA9IFticFswXSwgYnBbMV1dO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTmVpZ2hib3JzOyArK2kpIHtcbiAgICAgIHZhciBuaWQgPSBuZWlnaGJvcnNbaV07XG4gICAgICB2YXIgbnAgPSBCb2lkLnByb3RvdHlwZS5wb3NbbmlkXTtcblxuICAgICAgZ29hbFswXSArPSBucFswXTtcbiAgICAgIGdvYWxbMV0gKz0gbnBbMV07XG4gICAgfVxuICAgIGdvYWxbMF0gLz0gbnVtTmVpZ2hib3JzKzE7XG4gICAgZ29hbFsxXSAvPSBudW1OZWlnaGJvcnMrMTtcblxuICAgIHJldHVybiBnb2FsO1xuICB9XG5cbiAgRmxvY2sucHJvdG90eXBlLmRlYnVnRHJhdyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgbGV0IG51bUJvaWRzID0gdGhpcy5ib2lkcy5sZW5ndGg7XG4gICAgbGV0IHNwZWNpYWxCb2lkSWQgPSAwO1xuICAgIGxldCBza2lwUmVndWxhckJvaWRzID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGlkeEJvaWQgPSAwOyBpZHhCb2lkIDwgbnVtQm9pZHM7ICsraWR4Qm9pZCkge1xuICAgICAgaWYgKHNraXBSZWd1bGFyQm9pZHMgJiYgaWR4Qm9pZCAhPSBzcGVjaWFsQm9pZElkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYnAgPSBCb2lkLnByb3RvdHlwZS5wb3NbaWR4Qm9pZF07XG5cbiAgICAgIC8vIGRyYXcgbmVpZ2hib3JEaXN0IHJhbmdlXG4gICAgICBkcmF3Q2lyY2xlKGNvbnRleHQsIGJwWzBdLCBicFsxXSwgdGhpcy5uZWlnaGJvckRpc3QsICdkYXJrZ3JheScsIDAuNSk7XG5cbiAgICAgIHZhciBuZWlnaGJvcnMgPSBCb2lkLnByb3RvdHlwZS5uZWlnaGJvcnNbaWR4Qm9pZF07XG4gICAgICB2YXIgbnVtTmVpZ2hib3JzID0gbmVpZ2hib3JzLmxlbmd0aDtcbiAgICAgIGlmIChudW1OZWlnaGJvcnMgPiAwKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcInJlZFwiOyAvL1wiaHNsYShcIiArIHRoaXMuaHVlICsgXCIsMTAwJSw1MCUsMSlcIjtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAwLjU7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGxldCBwb3MgPSBCb2lkLnByb3RvdHlwZS5jZW50cm9pZFtpZHhCb2lkXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1OZWlnaGJvcnM7ICsraSkge1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBvc1swXSwgcG9zWzFdKTtcbiAgICAgICAgICB2YXIgbmlkID0gbmVpZ2hib3JzW2ldO1xuICAgICAgICAgIHZhciBucCA9IEJvaWQucHJvdG90eXBlLnBvc1tuaWRdO1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKG5wWzBdLCBucFsxXSk7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHBvc1swXSwgcG9zWzFdKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oYnBbMF0sIGJwWzFdKTtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcblxuICAgICAgICB4eXooY29udGV4dCwgcG9zWzBdLCBwb3NbMV0sIDIsIFwid2hpdGVcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJhd0NpcmNsZShjb250ZXh0LCB4LCB5LCByYWRpdXMsIGNvbG9yLCB3aWR0aCkge1xuICAgIGNvbnRleHQubW92ZVRvKHggKyByYWRpdXMsIHkpXG4gICAgY29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCAwLCAyKk1hdGguUEksIGZhbHNlKTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24geHl6KGNvbnRleHQsIHgsIHksIHJhZGl1cywgY29sb3IpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCAwLCAyKk1hdGguUEksIGZhbHNlKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxuXG4gIEZsb2NrLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBudW1Cb2lkcyA9IHRoaXMuYm9pZHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGlkeEJvaWQgPSAwOyBpZHhCb2lkIDwgbnVtQm9pZHM7ICsraWR4Qm9pZCkge1xuICAgICAgdGhpcy5ib2lkc1tpZHhCb2lkXS5kcmF3KGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBGbG9jaztcbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL2Zsb2NrLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pbGRvIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coXCJNSUxET1wiKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9taWxkby5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9