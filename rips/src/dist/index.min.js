/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = (function () {
  Boid.prototype.numBoids = 0;
  Boid.prototype.pos = [];
  Boid.prototype.vel = [];
  Boid.prototype.neighbors = [];
  Boid.prototype.centroid = [];

  function Boid(pos, vel) {
    this.id = Boid.prototype.numBoids++;
    Boid.prototype.pos[this.id] = pos;
    Boid.prototype.vel[this.id] = vel;
    Boid.prototype.neighbors[this.id] = [];
  }

  Boid.prototype.constructor = Boid

  Boid.prototype.separate = function () {
    var neighbors = Boid.prototype.neighbors[this.id]
    var numNeighbors = neighbors.length;
    var av = [0, 0];
    var bp = Boid.prototype.pos[this.id];
    var threshold = 100*100;
    for (var i = 0; i < numNeighbors; ++i) {
      var nid = neighbors[i];
      var np = Boid.prototype.pos[nid];

      var d = [0, 0];
      d[0] = bp[0] - np[0];
      d[1] = bp[1] - np[1];
      var ds = d[0]*d[0] + d[1]*d[1];
      if (ds < threshold) {
        // NOTE add factor to prevent divide by 0
        ds += 0.1;
        var factor = threshold / ds;
        av[0] += d[0] * factor;
        av[1] += d[1] * factor;
      }
    }
    av = normalize(av);

    return av;
  }

  Boid.prototype.cohere = function () {
    var cv = [0, 0];
    if (Boid.prototype.neighbors[this.id].length === 0) {
      return cv;
    }

    goal = Boid.prototype.centroid[this.id];
    var bp = Boid.prototype.pos[this.id];
    cv[0] = goal[0] - bp[0];
    cv[1] = goal[1] - bp[1];
    return cv;
  }

  function clamper() {

  }

  Boid.prototype.update = function (dt) {
    // velocity modifiers
    var sv = this.separate();
    var sf = 0.0;

    var cv = this.cohere();
    // let dist2 = dot(cv, cv);
    // if (dist2 < 4 || dist2 > 120) {
    //   cv = [0, 0];
    // }
    var cf = 0.0;

    //----
    let bvc = 0.99999999;
    var bv = Boid.prototype.vel[this.id];

    var vm = [0, 0];
    vm[0] = sf*sv[0] + cf*cv[0] + bvc*bv[0];
    vm[1] = sf*sv[1] + cf*cv[1] + bvc*bv[1];

    let vl = Math.sqrt(dot(vm, vm));
    if (vl > 4) {
      vm = normalize(vm);
      vm[0] *= 4;
      vm[1] *= 4;
    }

    Boid.prototype.vel[this.id] = vm;
  }

  Boid.prototype.move = function (dt) {
    let vc = 1;
    Boid.prototype.pos[this.id][0] += (vc * Boid.prototype.vel[this.id][0]);
    Boid.prototype.pos[this.id][1] += (vc * Boid.prototype.vel[this.id][1]);

    // keep boid within limits
    var width = 200; //context.canvas.width - 1;
    var height = 200; //context.canvas.height - 1;

    var bx = Boid.prototype.pos[this.id][0];
    if (bx >= width) {
      Boid.prototype.pos[this.id][0] = 0; // bx - width;
    } else if (bx < 0) {
      Boid.prototype.pos[this.id][0] = width; // bx + width;
    }

    var by = Boid.prototype.pos[this.id][1];
    if (by >= height) {
      Boid.prototype.pos[this.id][1] = 0; // by - height;
    } else if (by < 0) {
      Boid.prototype.pos[this.id][1] = height; // by + height;
    }
  }

  Boid.prototype.draw = function (context) {
    this.ctx = context;

    var x = Boid.prototype.pos[this.id][0];
    var y = Boid.prototype.pos[this.id][1];

    context.beginPath();
    context.fillStyle = "orange";
    if (this.id != 0) {
      context.fillStyle = "lightyellow";
    }
    context.arc(x, y, 4, 0, 2*Math.PI, false);
    context.fill();
  }

  function sayIt() {
    console.log("HEEBEE JEEBEE");
  }

  Boid.prototype.blah = function () {
    sayIt();
  }

  return Boid;
})();


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flock_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mildo__ = __webpack_require__(6);
// import Boid from './Boid'
var Grid = __webpack_require__(2)();



const Flock = Object(__WEBPACK_IMPORTED_MODULE_0__flock_js__["a" /* default */])();

//--[ step ]--------------------------------------------------------------
function step(timestamp) {
  let frameTimeMs = timestamp - last;
  last = timestamp;
  // console.log(frameTimeMs);

  // frames per second
  let elapsedTime = (timestamp - startTime) / 1000,
  result = Math.floor((frame / elapsedTime));
  if (elapsedTime > 1) {
    startTime = timestamp;
    frame = 0;
  }
  if (frame % 10 == 0) {
    let fpsText = result.toString();
    // console.log(fpsText);
  }
  ++frame;

  context.fillStyle = "black";
  context.fillRect(0, 0, canvas.width, canvas.height);

  if (frame % 3 === 0) {
    f.update(timestamp);
  }
  f.spawn(0);
  f.debugDraw(context);
  f.draw(context);

  window.requestAnimationFrame(step);
}

//------------------------------------------------------------------------
var last = performance.now();
var startTime = last;
var frame = 0;

let m = new __WEBPACK_IMPORTED_MODULE_1__mildo__["a" /* default */]();

let ww = window.innerWidth;
let wh = window.innerHeight;
var canvas = document.getElementById('field');
var context = canvas.getContext('2d');
context.canvas.width = ww;
context.canvas.height = wh;

let g = new Grid(ww, wh, 100);
let f = new Flock(g);
f.createBoids(100);
//f.createSource(ww / 2, wh / 2);
f.createSource(25, 25);

window.requestAnimationFrame(step);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var Boid = __webpack_require__(0);

module.exports = (function () {
  // move to reset fn?
  Grid.prototype.width = 0;
  Grid.prototype.height = 0;
  Grid.prototype.cx = 0;
  Grid.prototype.cy = 0;
  Grid.prototype.minCellDim = 0;
  Grid.prototype.field = [];

  function Grid(width, height, minCellDim) {
    // x
    Grid.prototype.width = width;
    Grid.prototype.cx = Math.ceil(width / minCellDim);

    // y
    Grid.prototype.height = height;
    Grid.prototype.cy = Math.ceil(height / minCellDim);

    Grid.prototype.minCellDim = minCellDim;

    for (var x = 0; x < Grid.prototype.cx; ++x) {
      Grid.prototype.field[x] = []
      for (var y = 0; y < Grid.prototype.cy; ++y) {
        Grid.prototype.field[x].push([]);
      }
    }

    var endit = 0;
  }

  Grid.prototype.constructor = Grid;

  Grid.prototype.add = function(positions) {
    // clear the grid
    for (var x = 0; x < Grid.prototype.field.length; ++x) {
      for (var y = 0; y < Grid.prototype.field[0].length; ++y) {
        Grid.prototype.field[x][y] = []
      }
    }

    // do the adding
    var numPositions = positions.length;
    for (var idxPos = 0; idxPos < numPositions; ++idxPos) {
      var bp = positions[idxPos];
      var xc = Math.floor(bp[0] / Grid.prototype.minCellDim);
      var yc = Math.floor(bp[1] / Grid.prototype.minCellDim);
      if (Grid.prototype.field[xc] === undefined) {
        var break_here = true;
      }
      Grid.prototype.field[xc][yc].push(idxPos);
      // color boids based on position
      // Boid.prototype.hue[idxPos] = ((yc + xc) % 2) == 0 ? "blue" : "green"
    }

    // save the positions for the queries
    Grid.prototype.positions = positions;
  }

  Grid.prototype.query = function(mx, my) {
    var xc = Math.floor(mx / Grid.prototype.minCellDim);
    var yc = Math.floor(my / Grid.prototype.minCellDim);

    var selectedID = null;
    var minToBoidSqr = Grid.prototype.minCellDim * Grid.prototype.minCellDim;
    var candidates = Grid.prototype.field[xc][yc];
    var numCandidates = candidates.length;
    for (var idxCandidate = 0; idxCandidate < numCandidates; ++idxCandidate) {
      var candidateID = candidates[idxCandidate];
      var pos = Grid.prototype.positions[candidateID];
      var dx = pos[0] - mx;
      var dy = pos[1] - my;
      var toBoidSqr = dx*dx + dy*dy;
      if (toBoidSqr < 121 && toBoidSqr < minToBoidSqr) {
        selectedID = candidateID;
        minToBoidSqr = toBoidSqr;
      }
    }

    return selectedID;
  }

  Grid.prototype.findNeighbors = function(threshold, maxNeighbors) {
    var scaleFactor = 1000;
    var numBoids = Boid.prototype.numBoids;

    for (var idxBoid = 0; idxBoid < numBoids; ++idxBoid) {
      var bp = Boid.prototype.pos[idxBoid];
      var qx = bp[0];
      var qy = bp[1];

      var x0 = Math.floor((qx - threshold) / Grid.prototype.minCellDim);
      x0 = Math.max(0, x0);
      var x1 = Math.floor((qx + threshold) / Grid.prototype.minCellDim);
      x1 = Math.min(Grid.prototype.field.length - 1, x1);
      var y0 = Math.floor((qy - threshold) / Grid.prototype.minCellDim);
      y0 = Math.max(0, y0);
      var y1 = Math.floor((qy + threshold) / Grid.prototype.minCellDim);
      y1 = Math.min(Grid.prototype.field[0].length - 1, y1);

      var candidates = [];
      for (var x = x0; x <= x1; ++x) {
        for (var y = y0; y <= y1; ++y) {
          candidates.push.apply(candidates, Grid.prototype.field[x][y]);
        }
      }

      var neighbors = [];
      var tsqr = threshold * threshold;
      var numCandidates = candidates.length;
      for (var idxCandidate = 0; idxCandidate < numCandidates; ++idxCandidate) {
        var candidateID = candidates[idxCandidate];
        var cpos = Grid.prototype.positions[candidateID];
        var dx = cpos[0] - qx;
        var dy = cpos[1] - qy;
        var dsqr = dx*dx + dy*dy;
        if (dsqr <= tsqr && dsqr > nearlyZero) {
          neighbors.push(Math.ceil(dsqr) * scaleFactor + candidateID);
        }
      }
      // sort neighbors to get the closest
      neighbors = neighbors.sort(function(a,b){return a-b});
      neighbors = neighbors.slice(0, maxNeighbors);
      // strip off the position info to leave the IDs
      Boid.prototype.neighbors[idxBoid] = neighbors.map(function(x){return x % scaleFactor});
    }
  }

  return Grid;
})


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__draw2d_js__ = __webpack_require__(5);
__webpack_require__(4);

var Boid = __webpack_require__(0);

/* harmony default export */ __webpack_exports__["a"] = (function () {
  Flock.prototype.sources = [];

  function Flock(grid) {
    this.grid = grid;
    this.numActive = 0;
    this.boids = [];
    this.neighborDist = 75;
    this.maxNeighbors = 10;
  }

  Flock.prototype.constructor = Flock

  function createBoid() {
    var numSources = Flock.prototype.sources.length;
    var idxSource = randomInRange(0, numSources - 1, true);
    var src = Flock.prototype.sources[idxSource];
    var p = [src[0], src[1]];
    p[0] += Math.random() * 6 - 3;
    p[1] += Math.random() * 6 - 3;

    // set velocity (aka heading)
    var v = [(Math.random() - 0.5), (Math.random() - 0.5)];
    v = normalize(v);

    return new Boid(p, v);
  }

  Flock.prototype.createSource = function (x, y) {
    let nextSourceIdx = Flock.prototype.sources.length;
    Flock.prototype.sources[nextSourceIdx] = [x, y];
  }

  Flock.prototype.createBoids = function (numBoids) {
    this.numDesired = numBoids;
  }

  Flock.prototype.spawn = function (dt) {
    var numBoids = this.boids.length;
    this.numActive = Math.min(numBoids, this.numActive);
    if (this.numActive < this.numDesired) {
      ++this.numActive;
      if (this.numActive > numBoids) {
        this.boids[numBoids] = createBoid();
      }
    }
  }

  Flock.prototype.update = function (dt) {
    for (let idxBoid = 0; idxBoid < this.numActive; ++idxBoid) {
      this.boids[idxBoid].update(dt);
      this.boids[idxBoid].move(dt);
    }

    this.grid.add(Boid.prototype.pos);
    this.grid.findNeighbors(this.neighborDist, this.maxNeighbors);

    for (let idxBoid = 0; idxBoid < this.numActive; ++idxBoid) {
      Boid.prototype.centroid[idxBoid] = findGroupCentroid(idxBoid);
    }
  }

  function findGroupCentroid(boidId) {
    var neighbors = Boid.prototype.neighbors[boidId]
    var numNeighbors = neighbors.length;
    var bp = Boid.prototype.pos[boidId];
    var goal = [bp[0], bp[1]];
    for (var i = 0; i < numNeighbors; ++i) {
      var nid = neighbors[i];
      var np = Boid.prototype.pos[nid];

      goal[0] += np[0];
      goal[1] += np[1];
    }
    goal[0] /= numNeighbors+1;
    goal[1] /= numNeighbors+1;

    return goal;
  }

  Flock.prototype.debugDraw = function (context) {
    let numBoids = this.boids.length;
    let specialBoidId = 0;
    let skipRegularBoids = true;

    for (let idxBoid = 0; idxBoid < numBoids; ++idxBoid) {
      if (skipRegularBoids && idxBoid != specialBoidId) {
        continue;
      }

      var bp = Boid.prototype.pos[idxBoid];

      // draw neighborDist range
      drawCircle(context, bp[0], bp[1], this.neighborDist, 'darkgray', 0.5);

      var neighbors = Boid.prototype.neighbors[idxBoid];
      var numNeighbors = neighbors.length;
      if (numNeighbors > 0) {
        context.strokeStyle = "red"; //"hsla(" + this.hue + ",100%,50%,1)";
        context.lineWidth = 0.5;
        context.beginPath();
        let pos = Boid.prototype.centroid[idxBoid];
        for (var i = 0; i < numNeighbors; ++i) {
          context.moveTo(pos[0], pos[1]);
          var nid = neighbors[i];
          var np = Boid.prototype.pos[nid];
          context.lineTo(np[0], np[1]);
          context.stroke();
        }

        context.moveTo(pos[0], pos[1]);
        context.lineTo(bp[0], bp[1]);
        context.stroke();

        xyz(context, pos[0], pos[1], 2, "white");
      }
    }
  }

  function drawCircle(context, x, y, radius, color, width) {
    context.moveTo(x + radius, y)
    context.arc(x, y, radius, 0, 2*Math.PI, false);
    context.lineWidth = width;
    context.strokeStyle = color;
    context.stroke();
  }

  function xyz(context, x, y, radius, color) {
    context.beginPath();
    context.fillStyle = color;
    context.arc(x, y, radius, 0, 2*Math.PI, false);
    context.fill();
  }

  Flock.prototype.draw = function(context) {
    var numBoids = this.boids.length;
    for (var idxBoid = 0; idxBoid < numBoids; ++idxBoid) {
      this.boids[idxBoid].draw(context);
    }
  }

  return Flock;
});


/***/ }),
/* 4 */
/***/ (function(module, exports) {

//
// Simulation Math Utilities
//
// TODO FIX
// TODO this is just throwing everything into the
//      global namespace...
module.exports = (function () {
  this.nearlyZero = 0.00001;

  this.normalize = function (v) {
    let lv = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
    if (Math.abs(lv) > nearlyZero) {
      v[0] /= lv;
      v[1] /= lv;
    }
    return v;
  }

  this.dot = function(v1, v2) {
    return v1[0]*v2[0] + v1[1]*v2[1]
  }

  this.buildRotationMatrix = function(degrees) {
    var radians = degrees * Math.PI / 180.0;
    var matrix = [
      [Math.cos(radians), -Math.sin(radians)],
      [Math.sin(radians), Math.cos(radians)],
    ];
    return matrix;
  }

  this.rotate = function(v, m) {
    var x = m[0][0]*v[0] + m[0][1]*v[1]
    var y = m[1][0]*v[0] + m[1][1]*v[1]
    return [x, y];
  }

  this.randomInRange = function(min, max, wantInt) {
    var max = (max === 0 || max) ? max : 1,
        min = min || 0,
        gen = min + (max - min) * Math.random();

    return (wantInt) ? Math.round(gen) : gen;
  }

  return {
    // normalize: normalize,
    dot: dot,
    buildRotationMatrix: buildRotationMatrix,
    rotate: rotate,
    randomInRange: randomInRange
  };
})();


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export drawCircle */
function drawCircle(context, x, y, radius, color, width) {
  context.moveTo(x + radius, y)
  context.arc(x, y, radius, 0, 2*Math.PI, false);
  context.lineWidth = width;
  context.strokeStyle = color;
  context.stroke();
}


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class Mildo {
  constructor() {
    console.log("MILDO");
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Mildo;



/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjYwODA5ODgxNWYyMDMzOTcyMmYiLCJ3ZWJwYWNrOi8vLy4vanMvQm9pZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9ncmlkLmpzIiwid2VicGFjazovLy8uL2pzL2Zsb2NrLmpzIiwid2VicGFjazovLy8uL2pzL3NtdS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9kcmF3MmQuanMiLCJ3ZWJwYWNrOi8vLy4vanMvbWlsZG8uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7OztBQ3BERDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQSIsImZpbGUiOiJpbmRleC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBiNjA4MDk4ODE1ZjIwMzM5NzIyZiIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgQm9pZC5wcm90b3R5cGUubnVtQm9pZHMgPSAwO1xuICBCb2lkLnByb3RvdHlwZS5wb3MgPSBbXTtcbiAgQm9pZC5wcm90b3R5cGUudmVsID0gW107XG4gIEJvaWQucHJvdG90eXBlLm5laWdoYm9ycyA9IFtdO1xuICBCb2lkLnByb3RvdHlwZS5jZW50cm9pZCA9IFtdO1xuXG4gIGZ1bmN0aW9uIEJvaWQocG9zLCB2ZWwpIHtcbiAgICB0aGlzLmlkID0gQm9pZC5wcm90b3R5cGUubnVtQm9pZHMrKztcbiAgICBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF0gPSBwb3M7XG4gICAgQm9pZC5wcm90b3R5cGUudmVsW3RoaXMuaWRdID0gdmVsO1xuICAgIEJvaWQucHJvdG90eXBlLm5laWdoYm9yc1t0aGlzLmlkXSA9IFtdO1xuICB9XG5cbiAgQm9pZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb2lkXG5cbiAgQm9pZC5wcm90b3R5cGUuc2VwYXJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5laWdoYm9ycyA9IEJvaWQucHJvdG90eXBlLm5laWdoYm9yc1t0aGlzLmlkXVxuICAgIHZhciBudW1OZWlnaGJvcnMgPSBuZWlnaGJvcnMubGVuZ3RoO1xuICAgIHZhciBhdiA9IFswLCAwXTtcbiAgICB2YXIgYnAgPSBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF07XG4gICAgdmFyIHRocmVzaG9sZCA9IDEwMCoxMDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1OZWlnaGJvcnM7ICsraSkge1xuICAgICAgdmFyIG5pZCA9IG5laWdoYm9yc1tpXTtcbiAgICAgIHZhciBucCA9IEJvaWQucHJvdG90eXBlLnBvc1tuaWRdO1xuXG4gICAgICB2YXIgZCA9IFswLCAwXTtcbiAgICAgIGRbMF0gPSBicFswXSAtIG5wWzBdO1xuICAgICAgZFsxXSA9IGJwWzFdIC0gbnBbMV07XG4gICAgICB2YXIgZHMgPSBkWzBdKmRbMF0gKyBkWzFdKmRbMV07XG4gICAgICBpZiAoZHMgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgLy8gTk9URSBhZGQgZmFjdG9yIHRvIHByZXZlbnQgZGl2aWRlIGJ5IDBcbiAgICAgICAgZHMgKz0gMC4xO1xuICAgICAgICB2YXIgZmFjdG9yID0gdGhyZXNob2xkIC8gZHM7XG4gICAgICAgIGF2WzBdICs9IGRbMF0gKiBmYWN0b3I7XG4gICAgICAgIGF2WzFdICs9IGRbMV0gKiBmYWN0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIGF2ID0gbm9ybWFsaXplKGF2KTtcblxuICAgIHJldHVybiBhdjtcbiAgfVxuXG4gIEJvaWQucHJvdG90eXBlLmNvaGVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3YgPSBbMCwgMF07XG4gICAgaWYgKEJvaWQucHJvdG90eXBlLm5laWdoYm9yc1t0aGlzLmlkXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjdjtcbiAgICB9XG5cbiAgICBnb2FsID0gQm9pZC5wcm90b3R5cGUuY2VudHJvaWRbdGhpcy5pZF07XG4gICAgdmFyIGJwID0gQm9pZC5wcm90b3R5cGUucG9zW3RoaXMuaWRdO1xuICAgIGN2WzBdID0gZ29hbFswXSAtIGJwWzBdO1xuICAgIGN2WzFdID0gZ29hbFsxXSAtIGJwWzFdO1xuICAgIHJldHVybiBjdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYW1wZXIoKSB7XG5cbiAgfVxuXG4gIEJvaWQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkdCkge1xuICAgIC8vIHZlbG9jaXR5IG1vZGlmaWVyc1xuICAgIHZhciBzdiA9IHRoaXMuc2VwYXJhdGUoKTtcbiAgICB2YXIgc2YgPSAwLjA7XG5cbiAgICB2YXIgY3YgPSB0aGlzLmNvaGVyZSgpO1xuICAgIC8vIGxldCBkaXN0MiA9IGRvdChjdiwgY3YpO1xuICAgIC8vIGlmIChkaXN0MiA8IDQgfHwgZGlzdDIgPiAxMjApIHtcbiAgICAvLyAgIGN2ID0gWzAsIDBdO1xuICAgIC8vIH1cbiAgICB2YXIgY2YgPSAwLjA7XG5cbiAgICAvLy0tLS1cbiAgICBsZXQgYnZjID0gMC45OTk5OTk5OTtcbiAgICB2YXIgYnYgPSBCb2lkLnByb3RvdHlwZS52ZWxbdGhpcy5pZF07XG5cbiAgICB2YXIgdm0gPSBbMCwgMF07XG4gICAgdm1bMF0gPSBzZipzdlswXSArIGNmKmN2WzBdICsgYnZjKmJ2WzBdO1xuICAgIHZtWzFdID0gc2Yqc3ZbMV0gKyBjZipjdlsxXSArIGJ2YypidlsxXTtcblxuICAgIGxldCB2bCA9IE1hdGguc3FydChkb3Qodm0sIHZtKSk7XG4gICAgaWYgKHZsID4gNCkge1xuICAgICAgdm0gPSBub3JtYWxpemUodm0pO1xuICAgICAgdm1bMF0gKj0gNDtcbiAgICAgIHZtWzFdICo9IDQ7XG4gICAgfVxuXG4gICAgQm9pZC5wcm90b3R5cGUudmVsW3RoaXMuaWRdID0gdm07XG4gIH1cblxuICBCb2lkLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGR0KSB7XG4gICAgbGV0IHZjID0gMTtcbiAgICBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMF0gKz0gKHZjICogQm9pZC5wcm90b3R5cGUudmVsW3RoaXMuaWRdWzBdKTtcbiAgICBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMV0gKz0gKHZjICogQm9pZC5wcm90b3R5cGUudmVsW3RoaXMuaWRdWzFdKTtcblxuICAgIC8vIGtlZXAgYm9pZCB3aXRoaW4gbGltaXRzXG4gICAgdmFyIHdpZHRoID0gMjAwOyAvL2NvbnRleHQuY2FudmFzLndpZHRoIC0gMTtcbiAgICB2YXIgaGVpZ2h0ID0gMjAwOyAvL2NvbnRleHQuY2FudmFzLmhlaWdodCAtIDE7XG5cbiAgICB2YXIgYnggPSBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMF07XG4gICAgaWYgKGJ4ID49IHdpZHRoKSB7XG4gICAgICBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMF0gPSAwOyAvLyBieCAtIHdpZHRoO1xuICAgIH0gZWxzZSBpZiAoYnggPCAwKSB7XG4gICAgICBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMF0gPSB3aWR0aDsgLy8gYnggKyB3aWR0aDtcbiAgICB9XG5cbiAgICB2YXIgYnkgPSBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMV07XG4gICAgaWYgKGJ5ID49IGhlaWdodCkge1xuICAgICAgQm9pZC5wcm90b3R5cGUucG9zW3RoaXMuaWRdWzFdID0gMDsgLy8gYnkgLSBoZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChieSA8IDApIHtcbiAgICAgIEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVsxXSA9IGhlaWdodDsgLy8gYnkgKyBoZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgQm9pZC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xuXG4gICAgdmFyIHggPSBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMF07XG4gICAgdmFyIHkgPSBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMV07XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJvcmFuZ2VcIjtcbiAgICBpZiAodGhpcy5pZCAhPSAwKSB7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwibGlnaHR5ZWxsb3dcIjtcbiAgICB9XG4gICAgY29udGV4dC5hcmMoeCwgeSwgNCwgMCwgMipNYXRoLlBJLCBmYWxzZSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH1cblxuICBmdW5jdGlvbiBzYXlJdCgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkhFRUJFRSBKRUVCRUVcIik7XG4gIH1cblxuICBCb2lkLnByb3RvdHlwZS5ibGFoID0gZnVuY3Rpb24gKCkge1xuICAgIHNheUl0KCk7XG4gIH1cblxuICByZXR1cm4gQm9pZDtcbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL0JvaWQuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gaW1wb3J0IEJvaWQgZnJvbSAnLi9Cb2lkJ1xudmFyIEdyaWQgPSByZXF1aXJlKCcuL2dyaWQnKSgpO1xuaW1wb3J0IEZsb2NrRnVuY3Rpb24gZnJvbSAnLi9mbG9jay5qcyc7XG5pbXBvcnQgTWlsZG8gZnJvbSAnLi9taWxkbyc7XG5cbmNvbnN0IEZsb2NrID0gRmxvY2tGdW5jdGlvbigpO1xuXG4vLy0tWyBzdGVwIF0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc3RlcCh0aW1lc3RhbXApIHtcbiAgbGV0IGZyYW1lVGltZU1zID0gdGltZXN0YW1wIC0gbGFzdDtcbiAgbGFzdCA9IHRpbWVzdGFtcDtcbiAgLy8gY29uc29sZS5sb2coZnJhbWVUaW1lTXMpO1xuXG4gIC8vIGZyYW1lcyBwZXIgc2Vjb25kXG4gIGxldCBlbGFwc2VkVGltZSA9ICh0aW1lc3RhbXAgLSBzdGFydFRpbWUpIC8gMTAwMCxcbiAgcmVzdWx0ID0gTWF0aC5mbG9vcigoZnJhbWUgLyBlbGFwc2VkVGltZSkpO1xuICBpZiAoZWxhcHNlZFRpbWUgPiAxKSB7XG4gICAgc3RhcnRUaW1lID0gdGltZXN0YW1wO1xuICAgIGZyYW1lID0gMDtcbiAgfVxuICBpZiAoZnJhbWUgJSAxMCA9PSAwKSB7XG4gICAgbGV0IGZwc1RleHQgPSByZXN1bHQudG9TdHJpbmcoKTtcbiAgICAvLyBjb25zb2xlLmxvZyhmcHNUZXh0KTtcbiAgfVxuICArK2ZyYW1lO1xuXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gXCJibGFja1wiO1xuICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgaWYgKGZyYW1lICUgMyA9PT0gMCkge1xuICAgIGYudXBkYXRlKHRpbWVzdGFtcCk7XG4gIH1cbiAgZi5zcGF3bigwKTtcbiAgZi5kZWJ1Z0RyYXcoY29udGV4dCk7XG4gIGYuZHJhdyhjb250ZXh0KTtcblxuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIGxhc3QgPSBwZXJmb3JtYW5jZS5ub3coKTtcbnZhciBzdGFydFRpbWUgPSBsYXN0O1xudmFyIGZyYW1lID0gMDtcblxubGV0IG0gPSBuZXcgTWlsZG8oKTtcblxubGV0IHd3ID0gd2luZG93LmlubmVyV2lkdGg7XG5sZXQgd2ggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG52YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpZWxkJyk7XG52YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuY29udGV4dC5jYW52YXMud2lkdGggPSB3dztcbmNvbnRleHQuY2FudmFzLmhlaWdodCA9IHdoO1xuXG5sZXQgZyA9IG5ldyBHcmlkKHd3LCB3aCwgMTAwKTtcbmxldCBmID0gbmV3IEZsb2NrKGcpO1xuZi5jcmVhdGVCb2lkcygxMDApO1xuLy9mLmNyZWF0ZVNvdXJjZSh3dyAvIDIsIHdoIC8gMik7XG5mLmNyZWF0ZVNvdXJjZSgyNSwgMjUpO1xuXG53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgQm9pZCA9IHJlcXVpcmUoJy4vQm9pZC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIG1vdmUgdG8gcmVzZXQgZm4/XG4gIEdyaWQucHJvdG90eXBlLndpZHRoID0gMDtcbiAgR3JpZC5wcm90b3R5cGUuaGVpZ2h0ID0gMDtcbiAgR3JpZC5wcm90b3R5cGUuY3ggPSAwO1xuICBHcmlkLnByb3RvdHlwZS5jeSA9IDA7XG4gIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0gPSAwO1xuICBHcmlkLnByb3RvdHlwZS5maWVsZCA9IFtdO1xuXG4gIGZ1bmN0aW9uIEdyaWQod2lkdGgsIGhlaWdodCwgbWluQ2VsbERpbSkge1xuICAgIC8vIHhcbiAgICBHcmlkLnByb3RvdHlwZS53aWR0aCA9IHdpZHRoO1xuICAgIEdyaWQucHJvdG90eXBlLmN4ID0gTWF0aC5jZWlsKHdpZHRoIC8gbWluQ2VsbERpbSk7XG5cbiAgICAvLyB5XG4gICAgR3JpZC5wcm90b3R5cGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIEdyaWQucHJvdG90eXBlLmN5ID0gTWF0aC5jZWlsKGhlaWdodCAvIG1pbkNlbGxEaW0pO1xuXG4gICAgR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSA9IG1pbkNlbGxEaW07XG5cbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IEdyaWQucHJvdG90eXBlLmN4OyArK3gpIHtcbiAgICAgIEdyaWQucHJvdG90eXBlLmZpZWxkW3hdID0gW11cbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgR3JpZC5wcm90b3R5cGUuY3k7ICsreSkge1xuICAgICAgICBHcmlkLnByb3RvdHlwZS5maWVsZFt4XS5wdXNoKFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZW5kaXQgPSAwO1xuICB9XG5cbiAgR3JpZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmlkO1xuXG4gIEdyaWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgIC8vIGNsZWFyIHRoZSBncmlkXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBHcmlkLnByb3RvdHlwZS5maWVsZC5sZW5ndGg7ICsreCkge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBHcmlkLnByb3RvdHlwZS5maWVsZFswXS5sZW5ndGg7ICsreSkge1xuICAgICAgICBHcmlkLnByb3RvdHlwZS5maWVsZFt4XVt5XSA9IFtdXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZG8gdGhlIGFkZGluZ1xuICAgIHZhciBudW1Qb3NpdGlvbnMgPSBwb3NpdGlvbnMubGVuZ3RoO1xuICAgIGZvciAodmFyIGlkeFBvcyA9IDA7IGlkeFBvcyA8IG51bVBvc2l0aW9uczsgKytpZHhQb3MpIHtcbiAgICAgIHZhciBicCA9IHBvc2l0aW9uc1tpZHhQb3NdO1xuICAgICAgdmFyIHhjID0gTWF0aC5mbG9vcihicFswXSAvIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0pO1xuICAgICAgdmFyIHljID0gTWF0aC5mbG9vcihicFsxXSAvIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0pO1xuICAgICAgaWYgKEdyaWQucHJvdG90eXBlLmZpZWxkW3hjXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBicmVha19oZXJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIEdyaWQucHJvdG90eXBlLmZpZWxkW3hjXVt5Y10ucHVzaChpZHhQb3MpO1xuICAgICAgLy8gY29sb3IgYm9pZHMgYmFzZWQgb24gcG9zaXRpb25cbiAgICAgIC8vIEJvaWQucHJvdG90eXBlLmh1ZVtpZHhQb3NdID0gKCh5YyArIHhjKSAlIDIpID09IDAgPyBcImJsdWVcIiA6IFwiZ3JlZW5cIlxuICAgIH1cblxuICAgIC8vIHNhdmUgdGhlIHBvc2l0aW9ucyBmb3IgdGhlIHF1ZXJpZXNcbiAgICBHcmlkLnByb3RvdHlwZS5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gIH1cblxuICBHcmlkLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKG14LCBteSkge1xuICAgIHZhciB4YyA9IE1hdGguZmxvb3IobXggLyBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltKTtcbiAgICB2YXIgeWMgPSBNYXRoLmZsb29yKG15IC8gR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSk7XG5cbiAgICB2YXIgc2VsZWN0ZWRJRCA9IG51bGw7XG4gICAgdmFyIG1pblRvQm9pZFNxciA9IEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0gKiBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltO1xuICAgIHZhciBjYW5kaWRhdGVzID0gR3JpZC5wcm90b3R5cGUuZmllbGRbeGNdW3ljXTtcbiAgICB2YXIgbnVtQ2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGlkeENhbmRpZGF0ZSA9IDA7IGlkeENhbmRpZGF0ZSA8IG51bUNhbmRpZGF0ZXM7ICsraWR4Q2FuZGlkYXRlKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlSUQgPSBjYW5kaWRhdGVzW2lkeENhbmRpZGF0ZV07XG4gICAgICB2YXIgcG9zID0gR3JpZC5wcm90b3R5cGUucG9zaXRpb25zW2NhbmRpZGF0ZUlEXTtcbiAgICAgIHZhciBkeCA9IHBvc1swXSAtIG14O1xuICAgICAgdmFyIGR5ID0gcG9zWzFdIC0gbXk7XG4gICAgICB2YXIgdG9Cb2lkU3FyID0gZHgqZHggKyBkeSpkeTtcbiAgICAgIGlmICh0b0JvaWRTcXIgPCAxMjEgJiYgdG9Cb2lkU3FyIDwgbWluVG9Cb2lkU3FyKSB7XG4gICAgICAgIHNlbGVjdGVkSUQgPSBjYW5kaWRhdGVJRDtcbiAgICAgICAgbWluVG9Cb2lkU3FyID0gdG9Cb2lkU3FyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3RlZElEO1xuICB9XG5cbiAgR3JpZC5wcm90b3R5cGUuZmluZE5laWdoYm9ycyA9IGZ1bmN0aW9uKHRocmVzaG9sZCwgbWF4TmVpZ2hib3JzKSB7XG4gICAgdmFyIHNjYWxlRmFjdG9yID0gMTAwMDtcbiAgICB2YXIgbnVtQm9pZHMgPSBCb2lkLnByb3RvdHlwZS5udW1Cb2lkcztcblxuICAgIGZvciAodmFyIGlkeEJvaWQgPSAwOyBpZHhCb2lkIDwgbnVtQm9pZHM7ICsraWR4Qm9pZCkge1xuICAgICAgdmFyIGJwID0gQm9pZC5wcm90b3R5cGUucG9zW2lkeEJvaWRdO1xuICAgICAgdmFyIHF4ID0gYnBbMF07XG4gICAgICB2YXIgcXkgPSBicFsxXTtcblxuICAgICAgdmFyIHgwID0gTWF0aC5mbG9vcigocXggLSB0aHJlc2hvbGQpIC8gR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSk7XG4gICAgICB4MCA9IE1hdGgubWF4KDAsIHgwKTtcbiAgICAgIHZhciB4MSA9IE1hdGguZmxvb3IoKHF4ICsgdGhyZXNob2xkKSAvIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0pO1xuICAgICAgeDEgPSBNYXRoLm1pbihHcmlkLnByb3RvdHlwZS5maWVsZC5sZW5ndGggLSAxLCB4MSk7XG4gICAgICB2YXIgeTAgPSBNYXRoLmZsb29yKChxeSAtIHRocmVzaG9sZCkgLyBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltKTtcbiAgICAgIHkwID0gTWF0aC5tYXgoMCwgeTApO1xuICAgICAgdmFyIHkxID0gTWF0aC5mbG9vcigocXkgKyB0aHJlc2hvbGQpIC8gR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSk7XG4gICAgICB5MSA9IE1hdGgubWluKEdyaWQucHJvdG90eXBlLmZpZWxkWzBdLmxlbmd0aCAtIDEsIHkxKTtcblxuICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIHggPSB4MDsgeCA8PSB4MTsgKyt4KSB7XG4gICAgICAgIGZvciAodmFyIHkgPSB5MDsgeSA8PSB5MTsgKyt5KSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoLmFwcGx5KGNhbmRpZGF0ZXMsIEdyaWQucHJvdG90eXBlLmZpZWxkW3hdW3ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmVpZ2hib3JzID0gW107XG4gICAgICB2YXIgdHNxciA9IHRocmVzaG9sZCAqIHRocmVzaG9sZDtcbiAgICAgIHZhciBudW1DYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpZHhDYW5kaWRhdGUgPSAwOyBpZHhDYW5kaWRhdGUgPCBudW1DYW5kaWRhdGVzOyArK2lkeENhbmRpZGF0ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlSUQgPSBjYW5kaWRhdGVzW2lkeENhbmRpZGF0ZV07XG4gICAgICAgIHZhciBjcG9zID0gR3JpZC5wcm90b3R5cGUucG9zaXRpb25zW2NhbmRpZGF0ZUlEXTtcbiAgICAgICAgdmFyIGR4ID0gY3Bvc1swXSAtIHF4O1xuICAgICAgICB2YXIgZHkgPSBjcG9zWzFdIC0gcXk7XG4gICAgICAgIHZhciBkc3FyID0gZHgqZHggKyBkeSpkeTtcbiAgICAgICAgaWYgKGRzcXIgPD0gdHNxciAmJiBkc3FyID4gbmVhcmx5WmVybykge1xuICAgICAgICAgIG5laWdoYm9ycy5wdXNoKE1hdGguY2VpbChkc3FyKSAqIHNjYWxlRmFjdG9yICsgY2FuZGlkYXRlSUQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBzb3J0IG5laWdoYm9ycyB0byBnZXQgdGhlIGNsb3Nlc3RcbiAgICAgIG5laWdoYm9ycyA9IG5laWdoYm9ycy5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEtYn0pO1xuICAgICAgbmVpZ2hib3JzID0gbmVpZ2hib3JzLnNsaWNlKDAsIG1heE5laWdoYm9ycyk7XG4gICAgICAvLyBzdHJpcCBvZmYgdGhlIHBvc2l0aW9uIGluZm8gdG8gbGVhdmUgdGhlIElEc1xuICAgICAgQm9pZC5wcm90b3R5cGUubmVpZ2hib3JzW2lkeEJvaWRdID0gbmVpZ2hib3JzLm1hcChmdW5jdGlvbih4KXtyZXR1cm4geCAlIHNjYWxlRmFjdG9yfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEdyaWQ7XG59KVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9ncmlkLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoJy4vc211LmpzJyk7XG5pbXBvcnQgeyBkcmF3Q2lyY2xlIH0gZnJvbSAnLi9kcmF3MmQuanMnO1xudmFyIEJvaWQgPSByZXF1aXJlKCcuL0JvaWQuanMnKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICBGbG9jay5wcm90b3R5cGUuc291cmNlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIEZsb2NrKGdyaWQpIHtcbiAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgIHRoaXMubnVtQWN0aXZlID0gMDtcbiAgICB0aGlzLmJvaWRzID0gW107XG4gICAgdGhpcy5uZWlnaGJvckRpc3QgPSA3NTtcbiAgICB0aGlzLm1heE5laWdoYm9ycyA9IDEwO1xuICB9XG5cbiAgRmxvY2sucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmxvY2tcblxuICBmdW5jdGlvbiBjcmVhdGVCb2lkKCkge1xuICAgIHZhciBudW1Tb3VyY2VzID0gRmxvY2sucHJvdG90eXBlLnNvdXJjZXMubGVuZ3RoO1xuICAgIHZhciBpZHhTb3VyY2UgPSByYW5kb21JblJhbmdlKDAsIG51bVNvdXJjZXMgLSAxLCB0cnVlKTtcbiAgICB2YXIgc3JjID0gRmxvY2sucHJvdG90eXBlLnNvdXJjZXNbaWR4U291cmNlXTtcbiAgICB2YXIgcCA9IFtzcmNbMF0sIHNyY1sxXV07XG4gICAgcFswXSArPSBNYXRoLnJhbmRvbSgpICogNiAtIDM7XG4gICAgcFsxXSArPSBNYXRoLnJhbmRvbSgpICogNiAtIDM7XG5cbiAgICAvLyBzZXQgdmVsb2NpdHkgKGFrYSBoZWFkaW5nKVxuICAgIHZhciB2ID0gWyhNYXRoLnJhbmRvbSgpIC0gMC41KSwgKE1hdGgucmFuZG9tKCkgLSAwLjUpXTtcbiAgICB2ID0gbm9ybWFsaXplKHYpO1xuXG4gICAgcmV0dXJuIG5ldyBCb2lkKHAsIHYpO1xuICB9XG5cbiAgRmxvY2sucHJvdG90eXBlLmNyZWF0ZVNvdXJjZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgbGV0IG5leHRTb3VyY2VJZHggPSBGbG9jay5wcm90b3R5cGUuc291cmNlcy5sZW5ndGg7XG4gICAgRmxvY2sucHJvdG90eXBlLnNvdXJjZXNbbmV4dFNvdXJjZUlkeF0gPSBbeCwgeV07XG4gIH1cblxuICBGbG9jay5wcm90b3R5cGUuY3JlYXRlQm9pZHMgPSBmdW5jdGlvbiAobnVtQm9pZHMpIHtcbiAgICB0aGlzLm51bURlc2lyZWQgPSBudW1Cb2lkcztcbiAgfVxuXG4gIEZsb2NrLnByb3RvdHlwZS5zcGF3biA9IGZ1bmN0aW9uIChkdCkge1xuICAgIHZhciBudW1Cb2lkcyA9IHRoaXMuYm9pZHMubGVuZ3RoO1xuICAgIHRoaXMubnVtQWN0aXZlID0gTWF0aC5taW4obnVtQm9pZHMsIHRoaXMubnVtQWN0aXZlKTtcbiAgICBpZiAodGhpcy5udW1BY3RpdmUgPCB0aGlzLm51bURlc2lyZWQpIHtcbiAgICAgICsrdGhpcy5udW1BY3RpdmU7XG4gICAgICBpZiAodGhpcy5udW1BY3RpdmUgPiBudW1Cb2lkcykge1xuICAgICAgICB0aGlzLmJvaWRzW251bUJvaWRzXSA9IGNyZWF0ZUJvaWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBGbG9jay5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGR0KSB7XG4gICAgZm9yIChsZXQgaWR4Qm9pZCA9IDA7IGlkeEJvaWQgPCB0aGlzLm51bUFjdGl2ZTsgKytpZHhCb2lkKSB7XG4gICAgICB0aGlzLmJvaWRzW2lkeEJvaWRdLnVwZGF0ZShkdCk7XG4gICAgICB0aGlzLmJvaWRzW2lkeEJvaWRdLm1vdmUoZHQpO1xuICAgIH1cblxuICAgIHRoaXMuZ3JpZC5hZGQoQm9pZC5wcm90b3R5cGUucG9zKTtcbiAgICB0aGlzLmdyaWQuZmluZE5laWdoYm9ycyh0aGlzLm5laWdoYm9yRGlzdCwgdGhpcy5tYXhOZWlnaGJvcnMpO1xuXG4gICAgZm9yIChsZXQgaWR4Qm9pZCA9IDA7IGlkeEJvaWQgPCB0aGlzLm51bUFjdGl2ZTsgKytpZHhCb2lkKSB7XG4gICAgICBCb2lkLnByb3RvdHlwZS5jZW50cm9pZFtpZHhCb2lkXSA9IGZpbmRHcm91cENlbnRyb2lkKGlkeEJvaWQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRHcm91cENlbnRyb2lkKGJvaWRJZCkge1xuICAgIHZhciBuZWlnaGJvcnMgPSBCb2lkLnByb3RvdHlwZS5uZWlnaGJvcnNbYm9pZElkXVxuICAgIHZhciBudW1OZWlnaGJvcnMgPSBuZWlnaGJvcnMubGVuZ3RoO1xuICAgIHZhciBicCA9IEJvaWQucHJvdG90eXBlLnBvc1tib2lkSWRdO1xuICAgIHZhciBnb2FsID0gW2JwWzBdLCBicFsxXV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1OZWlnaGJvcnM7ICsraSkge1xuICAgICAgdmFyIG5pZCA9IG5laWdoYm9yc1tpXTtcbiAgICAgIHZhciBucCA9IEJvaWQucHJvdG90eXBlLnBvc1tuaWRdO1xuXG4gICAgICBnb2FsWzBdICs9IG5wWzBdO1xuICAgICAgZ29hbFsxXSArPSBucFsxXTtcbiAgICB9XG4gICAgZ29hbFswXSAvPSBudW1OZWlnaGJvcnMrMTtcbiAgICBnb2FsWzFdIC89IG51bU5laWdoYm9ycysxO1xuXG4gICAgcmV0dXJuIGdvYWw7XG4gIH1cblxuICBGbG9jay5wcm90b3R5cGUuZGVidWdEcmF3ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBsZXQgbnVtQm9pZHMgPSB0aGlzLmJvaWRzLmxlbmd0aDtcbiAgICBsZXQgc3BlY2lhbEJvaWRJZCA9IDA7XG4gICAgbGV0IHNraXBSZWd1bGFyQm9pZHMgPSB0cnVlO1xuXG4gICAgZm9yIChsZXQgaWR4Qm9pZCA9IDA7IGlkeEJvaWQgPCBudW1Cb2lkczsgKytpZHhCb2lkKSB7XG4gICAgICBpZiAoc2tpcFJlZ3VsYXJCb2lkcyAmJiBpZHhCb2lkICE9IHNwZWNpYWxCb2lkSWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBicCA9IEJvaWQucHJvdG90eXBlLnBvc1tpZHhCb2lkXTtcblxuICAgICAgLy8gZHJhdyBuZWlnaGJvckRpc3QgcmFuZ2VcbiAgICAgIGRyYXdDaXJjbGUoY29udGV4dCwgYnBbMF0sIGJwWzFdLCB0aGlzLm5laWdoYm9yRGlzdCwgJ2RhcmtncmF5JywgMC41KTtcblxuICAgICAgdmFyIG5laWdoYm9ycyA9IEJvaWQucHJvdG90eXBlLm5laWdoYm9yc1tpZHhCb2lkXTtcbiAgICAgIHZhciBudW1OZWlnaGJvcnMgPSBuZWlnaGJvcnMubGVuZ3RoO1xuICAgICAgaWYgKG51bU5laWdoYm9ycyA+IDApIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwicmVkXCI7IC8vXCJoc2xhKFwiICsgdGhpcy5odWUgKyBcIiwxMDAlLDUwJSwxKVwiO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDAuNTtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgbGV0IHBvcyA9IEJvaWQucHJvdG90eXBlLmNlbnRyb2lkW2lkeEJvaWRdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5laWdoYm9yczsgKytpKSB7XG4gICAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zWzBdLCBwb3NbMV0pO1xuICAgICAgICAgIHZhciBuaWQgPSBuZWlnaGJvcnNbaV07XG4gICAgICAgICAgdmFyIG5wID0gQm9pZC5wcm90b3R5cGUucG9zW25pZF07XG4gICAgICAgICAgY29udGV4dC5saW5lVG8obnBbMF0sIG5wWzFdKTtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zWzBdLCBwb3NbMV0pO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhicFswXSwgYnBbMV0pO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgICAgIHh5eihjb250ZXh0LCBwb3NbMF0sIHBvc1sxXSwgMiwgXCJ3aGl0ZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkcmF3Q2lyY2xlKGNvbnRleHQsIHgsIHksIHJhZGl1cywgY29sb3IsIHdpZHRoKSB7XG4gICAgY29udGV4dC5tb3ZlVG8oeCArIHJhZGl1cywgeSlcbiAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIqTWF0aC5QSSwgZmFsc2UpO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH1cblxuICBmdW5jdGlvbiB4eXooY29udGV4dCwgeCwgeSwgcmFkaXVzLCBjb2xvcikge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIqTWF0aC5QSSwgZmFsc2UpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG5cbiAgRmxvY2sucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIG51bUJvaWRzID0gdGhpcy5ib2lkcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaWR4Qm9pZCA9IDA7IGlkeEJvaWQgPCBudW1Cb2lkczsgKytpZHhCb2lkKSB7XG4gICAgICB0aGlzLmJvaWRzW2lkeEJvaWRdLmRyYXcoY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEZsb2NrO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9mbG9jay5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL1xuLy8gU2ltdWxhdGlvbiBNYXRoIFV0aWxpdGllc1xuLy9cbi8vIFRPRE8gRklYXG4vLyBUT0RPIHRoaXMgaXMganVzdCB0aHJvd2luZyBldmVyeXRoaW5nIGludG8gdGhlXG4vLyAgICAgIGdsb2JhbCBuYW1lc3BhY2UuLi5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5uZWFybHlaZXJvID0gMC4wMDAwMTtcblxuICB0aGlzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgbGV0IGx2ID0gTWF0aC5zcXJ0KHZbMF0qdlswXSArIHZbMV0qdlsxXSk7XG4gICAgaWYgKE1hdGguYWJzKGx2KSA+IG5lYXJseVplcm8pIHtcbiAgICAgIHZbMF0gLz0gbHY7XG4gICAgICB2WzFdIC89IGx2O1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIHRoaXMuZG90ID0gZnVuY3Rpb24odjEsIHYyKSB7XG4gICAgcmV0dXJuIHYxWzBdKnYyWzBdICsgdjFbMV0qdjJbMV1cbiAgfVxuXG4gIHRoaXMuYnVpbGRSb3RhdGlvbk1hdHJpeCA9IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcbiAgICB2YXIgcmFkaWFucyA9IGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgIFtNYXRoLmNvcyhyYWRpYW5zKSwgLU1hdGguc2luKHJhZGlhbnMpXSxcbiAgICAgIFtNYXRoLnNpbihyYWRpYW5zKSwgTWF0aC5jb3MocmFkaWFucyldLFxuICAgIF07XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuXG4gIHRoaXMucm90YXRlID0gZnVuY3Rpb24odiwgbSkge1xuICAgIHZhciB4ID0gbVswXVswXSp2WzBdICsgbVswXVsxXSp2WzFdXG4gICAgdmFyIHkgPSBtWzFdWzBdKnZbMF0gKyBtWzFdWzFdKnZbMV1cbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG5cbiAgdGhpcy5yYW5kb21JblJhbmdlID0gZnVuY3Rpb24obWluLCBtYXgsIHdhbnRJbnQpIHtcbiAgICB2YXIgbWF4ID0gKG1heCA9PT0gMCB8fCBtYXgpID8gbWF4IDogMSxcbiAgICAgICAgbWluID0gbWluIHx8IDAsXG4gICAgICAgIGdlbiA9IG1pbiArIChtYXggLSBtaW4pICogTWF0aC5yYW5kb20oKTtcblxuICAgIHJldHVybiAod2FudEludCkgPyBNYXRoLnJvdW5kKGdlbikgOiBnZW47XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIG5vcm1hbGl6ZTogbm9ybWFsaXplLFxuICAgIGRvdDogZG90LFxuICAgIGJ1aWxkUm90YXRpb25NYXRyaXg6IGJ1aWxkUm90YXRpb25NYXRyaXgsXG4gICAgcm90YXRlOiByb3RhdGUsXG4gICAgcmFuZG9tSW5SYW5nZTogcmFuZG9tSW5SYW5nZVxuICB9O1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vanMvc211LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBmdW5jdGlvbiBkcmF3Q2lyY2xlKGNvbnRleHQsIHgsIHksIHJhZGl1cywgY29sb3IsIHdpZHRoKSB7XG4gIGNvbnRleHQubW92ZVRvKHggKyByYWRpdXMsIHkpXG4gIGNvbnRleHQuYXJjKHgsIHksIHJhZGl1cywgMCwgMipNYXRoLlBJLCBmYWxzZSk7XG4gIGNvbnRleHQubGluZVdpZHRoID0gd2lkdGg7XG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY29udGV4dC5zdHJva2UoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vanMvZHJhdzJkLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pbGRvIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coXCJNSUxET1wiKTtcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9taWxkby5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9