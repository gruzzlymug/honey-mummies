/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__draw2d__ = __webpack_require__(1);


/* harmony default export */ __webpack_exports__["a"] = (function () {
  Boid.prototype.numBoids = 0;
  Boid.prototype.pos = [];
  Boid.prototype.vel = [];
  Boid.prototype.neighbors = [];
  Boid.prototype.centroid = [];

  function Boid(pos, vel) {
    this.id = Boid.prototype.numBoids++;
    Boid.prototype.pos[this.id] = pos;
    Boid.prototype.vel[this.id] = vel;
    Boid.prototype.neighbors[this.id] = [];
  }

  Boid.prototype.constructor = Boid

  Boid.prototype.separate = function () {
    var neighbors = Boid.prototype.neighbors[this.id]
    var numNeighbors = neighbors.length;
    var av = [0, 0];
    var bp = Boid.prototype.pos[this.id];
    var threshold = 100*100;
    for (var i = 0; i < numNeighbors; ++i) {
      var nid = neighbors[i];
      var np = Boid.prototype.pos[nid];

      var d = [0, 0];
      d[0] = bp[0] - np[0];
      d[1] = bp[1] - np[1];
      var ds = d[0]*d[0] + d[1]*d[1];
      if (ds < threshold) {
        // NOTE add factor to prevent divide by 0
        ds += 0.1;
        var factor = threshold / ds;
        av[0] += d[0] * factor;
        av[1] += d[1] * factor;
      }
    }
    av = normalize(av);

    return av;
  }

  Boid.prototype.cohere = function () {
    var cv = [0, 0];
    if (Boid.prototype.neighbors[this.id].length === 0) {
      return cv;
    }

    goal = Boid.prototype.centroid[this.id];
    var bp = Boid.prototype.pos[this.id];
    cv[0] = goal[0] - bp[0];
    cv[1] = goal[1] - bp[1];
    return cv;
  }

  function clamper() {

  }

  Boid.prototype.update = function (dt) {
    // velocity modifiers
    var sv = this.separate();
    var sf = 0.0;

    var cv = this.cohere();
    // let dist2 = dot(cv, cv);
    // if (dist2 < 4 || dist2 > 120) {
    //   cv = [0, 0];
    // }
    var cf = 0.0;

    //----
    let bvc = 0.99999999;
    var bv = Boid.prototype.vel[this.id];

    var vm = [0, 0];
    vm[0] = sf*sv[0] + cf*cv[0] + bvc*bv[0];
    vm[1] = sf*sv[1] + cf*cv[1] + bvc*bv[1];

    let vl = Math.sqrt(dot(vm, vm));
    if (vl > 4) {
      vm = normalize(vm);
      vm[0] *= 4;
      vm[1] *= 4;
    }

    Boid.prototype.vel[this.id] = vm;
  }

  Boid.prototype.move = function (dt) {
    let vc = 1;
    Boid.prototype.pos[this.id][0] += (vc * Boid.prototype.vel[this.id][0]);
    Boid.prototype.pos[this.id][1] += (vc * Boid.prototype.vel[this.id][1]);

    // keep boid within limits
    var width = 200; //context.canvas.width - 1;
    var height = 200; //context.canvas.height - 1;

    var bx = Boid.prototype.pos[this.id][0];
    if (bx >= width) {
      Boid.prototype.pos[this.id][0] = 0; // bx - width;
    } else if (bx < 0) {
      Boid.prototype.pos[this.id][0] = width; // bx + width;
    }

    var by = Boid.prototype.pos[this.id][1];
    if (by >= height) {
      Boid.prototype.pos[this.id][1] = 0; // by - height;
    } else if (by < 0) {
      Boid.prototype.pos[this.id][1] = height; // by + height;
    }
  }

  Boid.prototype.draw = function (context) {
    this.ctx = context;

    var x = Boid.prototype.pos[this.id][0];
    var y = Boid.prototype.pos[this.id][1];

    let radius = 4;
    // drawDot(context, x, y, radius, "white")
    Object(__WEBPACK_IMPORTED_MODULE_0__draw2d__["a" /* drawCircle */])(context, x, y, radius, "red", 0.5);
  }

  function sayIt() {
    console.log("HEEBEE JEEBEE");
  }

  Boid.prototype.blah = function () {
    sayIt();
  }

  return Boid;
});


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = drawCircle;
/* unused harmony export drawDot */
function drawCircle(context, x, y, radius, color, width) {
  context.beginPath();
  context.moveTo(x + radius, y)
  context.arc(x, y, radius, 0, 2*Math.PI, false);
  context.lineWidth = width;
  context.strokeStyle = color;
  context.stroke();
}

function drawDot(context, x, y, radius, color) {
  context.beginPath();
  context.fillStyle = color;
  context.arc(x, y, radius, 0, 2*Math.PI, false);
  context.fill();
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__grid__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flock_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mildo__ = __webpack_require__(6);
// import Boid from './Boid'




const Grid = Object(__WEBPACK_IMPORTED_MODULE_0__grid__["a" /* default */])();
const Flock = Object(__WEBPACK_IMPORTED_MODULE_1__flock_js__["a" /* default */])();

var flocks = [];

//--[ step ]--------------------------------------------------------------
// globals
// - flocks
// - ?
function step(timestamp) {
  let frameTimeMs = timestamp - last;
  last = timestamp;
  // console.log(frameTimeMs);

  // frames per second
  let elapsedTime = (timestamp - startTime) / 1000,
  result = Math.floor((frame / elapsedTime));
  if (elapsedTime > 1) {
    startTime = timestamp;
    frame = 0;
  }
  if (frame % 10 == 0) {
    let fpsText = result.toString();
    // console.log(fpsText);
  }
  ++frame;

  context.fillStyle = "black";
  context.fillRect(0, 0, canvas.width, canvas.height);

  if (frame % 3 === 0) {
    for (var i = 0, len = flocks.length; i < len; ++i) {
      flocks[i].update(timestamp);
    }
  }
  for (var i = 0, len = flocks.length; i < len; ++i) {
    flocks[i].spawn(0);
  }
  for (var i = 0, len = flocks.length; i < len; ++i) {
    flocks[i].debugDraw(context);
  }
  for (var i = 0, len = flocks.length; i < len; ++i) {
    flocks[i].draw(context);
  }

  window.requestAnimationFrame(step);
}

//------------------------------------------------------------------------
var last = performance.now();
var startTime = last;
var frame = 0;

let m = new __WEBPACK_IMPORTED_MODULE_2__mildo__["a" /* default */]();

let ww = window.innerWidth;
let wh = window.innerHeight;
var canvas = document.getElementById('field');
var context = canvas.getContext('2d');
context.canvas.width = ww;
context.canvas.height = wh;

let g = new Grid(ww, wh, 100);
flocks.push(new Flock(g));
flocks[0].createBoids(3);
//f.createSource(ww / 2, wh / 2);
flocks[0].createSource(25, 25);

let x = new Flock(g);
x.createBoids(1);
x.createSource(75, 75);

window.requestAnimationFrame(step);


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Boid_js__ = __webpack_require__(0);


const Boid = Object(__WEBPACK_IMPORTED_MODULE_0__Boid_js__["a" /* default */])();

/* harmony default export */ __webpack_exports__["a"] = (function () {
  // move to reset fn?
  Grid.prototype.width = 0;
  Grid.prototype.height = 0;
  Grid.prototype.cx = 0;
  Grid.prototype.cy = 0;
  Grid.prototype.minCellDim = 0;
  Grid.prototype.field = [];

  function Grid(width, height, minCellDim) {
    // x
    Grid.prototype.width = width;
    Grid.prototype.cx = Math.ceil(width / minCellDim);

    // y
    Grid.prototype.height = height;
    Grid.prototype.cy = Math.ceil(height / minCellDim);

    Grid.prototype.minCellDim = minCellDim;

    for (var x = 0; x < Grid.prototype.cx; ++x) {
      Grid.prototype.field[x] = []
      for (var y = 0; y < Grid.prototype.cy; ++y) {
        Grid.prototype.field[x].push([]);
      }
    }

    var endit = 0;
  }

  Grid.prototype.constructor = Grid;

  Grid.prototype.add = function(positions) {
    // clear the grid
    for (var x = 0; x < Grid.prototype.field.length; ++x) {
      for (var y = 0; y < Grid.prototype.field[0].length; ++y) {
        Grid.prototype.field[x][y] = []
      }
    }

    // do the adding
    var numPositions = positions.length;
    for (var idxPos = 0; idxPos < numPositions; ++idxPos) {
      var bp = positions[idxPos];
      var xc = Math.floor(bp[0] / Grid.prototype.minCellDim);
      var yc = Math.floor(bp[1] / Grid.prototype.minCellDim);
      if (Grid.prototype.field[xc] === undefined) {
        var break_here = true;
      }
      Grid.prototype.field[xc][yc].push(idxPos);
      // color boids based on position
      // Boid.prototype.hue[idxPos] = ((yc + xc) % 2) == 0 ? "blue" : "green"
    }

    // save the positions for the queries
    Grid.prototype.positions = positions;
  }

  Grid.prototype.query = function(mx, my) {
    var xc = Math.floor(mx / Grid.prototype.minCellDim);
    var yc = Math.floor(my / Grid.prototype.minCellDim);

    var selectedID = null;
    var minToBoidSqr = Grid.prototype.minCellDim * Grid.prototype.minCellDim;
    var candidates = Grid.prototype.field[xc][yc];
    var numCandidates = candidates.length;
    for (var idxCandidate = 0; idxCandidate < numCandidates; ++idxCandidate) {
      var candidateID = candidates[idxCandidate];
      var pos = Grid.prototype.positions[candidateID];
      var dx = pos[0] - mx;
      var dy = pos[1] - my;
      var toBoidSqr = dx*dx + dy*dy;
      if (toBoidSqr < 121 && toBoidSqr < minToBoidSqr) {
        selectedID = candidateID;
        minToBoidSqr = toBoidSqr;
      }
    }

    return selectedID;
  }

  // NOTE prototype is an OUT variable (modified within this fn)
  Grid.prototype.findNeighbors = function(threshold, maxNeighbors, prototype) {
    var scaleFactor = 1000;
    var numBoids = prototype.numBoids;

    for (var idxBoid = 0; idxBoid < numBoids; ++idxBoid) {
      var bp = prototype.pos[idxBoid];
      var qx = bp[0];
      var qy = bp[1];

      var x0 = Math.floor((qx - threshold) / Grid.prototype.minCellDim);
      x0 = Math.max(0, x0);
      var x1 = Math.floor((qx + threshold) / Grid.prototype.minCellDim);
      x1 = Math.min(Grid.prototype.field.length - 1, x1);
      var y0 = Math.floor((qy - threshold) / Grid.prototype.minCellDim);
      y0 = Math.max(0, y0);
      var y1 = Math.floor((qy + threshold) / Grid.prototype.minCellDim);
      y1 = Math.min(Grid.prototype.field[0].length - 1, y1);

      var candidates = [];
      for (var x = x0; x <= x1; ++x) {
        for (var y = y0; y <= y1; ++y) {
          candidates.push.apply(candidates, Grid.prototype.field[x][y]);
        }
      }

      var neighbors = [];
      var tsqr = threshold * threshold;
      var numCandidates = candidates.length;
      for (var idxCandidate = 0; idxCandidate < numCandidates; ++idxCandidate) {
        var candidateID = candidates[idxCandidate];
        var cpos = Grid.prototype.positions[candidateID];
        var dx = cpos[0] - qx;
        var dy = cpos[1] - qy;
        var dsqr = dx*dx + dy*dy;
        if (dsqr <= tsqr && dsqr > nearlyZero) {
          neighbors.push(Math.ceil(dsqr) * scaleFactor + candidateID);
        }
      }
      // sort neighbors to get the closest
      neighbors = neighbors.sort(function(a,b){return a-b});
      neighbors = neighbors.slice(0, maxNeighbors);
      // strip off the position info to leave the IDs
      prototype.neighbors[idxBoid] = neighbors.map(function(x){return x % scaleFactor});
    }
  }

  return Grid;
});


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__draw2d_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Boid_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__boid_std__ = __webpack_require__(7);
__webpack_require__(8);




const Boid = Object(__WEBPACK_IMPORTED_MODULE_1__Boid_js__["a" /* default */])();

/* harmony default export */ __webpack_exports__["a"] = (function () {
  Flock.prototype.numFlocks = 0;
  Flock.prototype.numBoids = 0;
  Flock.prototype.pos = [];
  Flock.prototype.vel = [];
  Flock.prototype.neighbors = [];
  Flock.prototype.centroid = [];

  Flock.prototype.sources = [];

  function Flock(grid) {
    this.id = Flock.prototype.numFlocks++;
    this.grid = grid;
    this.numActive = 0;
    this.boids = [];
    this.neighborDist = 75;
    this.maxNeighbors = 10;
  }

  Flock.prototype.constructor = Flock

  Flock.prototype.createBoid = function() {
    var numSources = Flock.prototype.sources.length;
    var idxSource = randomInRange(0, numSources - 1, true);
    var src = Flock.prototype.sources[idxSource];
    var p = [src[0], src[1]];
    p[0] += Math.random() * 6 - 3;
    p[1] += Math.random() * 6 - 3;

    // set velocity (aka heading)
    var v = [(Math.random() - 0.5), (Math.random() - 0.5)];
    v = normalize(v);

    let boidId = Flock.prototype.numBoids++;
    Flock.prototype.pos[boidId] = p;
    Flock.prototype.vel[boidId] = v;
    Flock.prototype.neighbors[boidId] = [];

    return boidId;
  }

  Flock.prototype.moveBoid = function (dt, boidId) {
    let vc = 1;
    Flock.prototype.pos[boidId][0] += (vc * Flock.prototype.vel[boidId][0]);
    Flock.prototype.pos[boidId][1] += (vc * Flock.prototype.vel[boidId][1]);

    // keep boid within limits
    var width = 200; //context.canvas.width - 1;
    var height = 200; //context.canvas.height - 1;

    var bx = Flock.prototype.pos[boidId][0];
    if (bx >= width) {
      Flock.prototype.pos[boidId][0] = 0; // bx - width;
    } else if (bx < 0) {
      Flock.prototype.pos[boidId][0] = width; // bx + width;
    }

    var by = Flock.prototype.pos[boidId][1];
    if (by >= height) {
      Flock.prototype.pos[boidId][1] = 0; // by - height;
    } else if (by < 0) {
      Flock.prototype.pos[boidId][1] = height; // by + height;
    }
  }

  Flock.prototype.drawBoid = function (context, boidId) {
    var x = Flock.prototype.pos[boidId][0];
    var y = Flock.prototype.pos[boidId][1];

    let radius = 4;
    // drawDot(context, x, y, radius, "white")
    Object(__WEBPACK_IMPORTED_MODULE_0__draw2d_js__["a" /* drawCircle */])(context, x, y, radius, "red", 0.5);
  }

  Flock.prototype.createSource = function (x, y) {
    let nextSourceIdx = Flock.prototype.sources.length;
    Flock.prototype.sources[nextSourceIdx] = [x, y];
  }

  Flock.prototype.createBoids = function (numBoids) {
    this.numDesired = numBoids;
  }

  Flock.prototype.spawn = function (dt) {
    var numBoids = this.boids.length;
    this.numActive = Math.min(numBoids, this.numActive);
    if (this.numActive < this.numDesired) {
      ++this.numActive;
      if (this.numActive > numBoids) {
        this.boids[numBoids] = Flock.prototype.createBoid();
      }
    }
  }

  Flock.prototype.update = function (dt) {
    for (let idxBoid = 0; idxBoid < this.numActive; ++idxBoid) {
      // this.boids[idxBoid].update(dt);
      let neighbors = Flock.prototype.neighbors[idxBoid];
      let v = __WEBPACK_IMPORTED_MODULE_2__boid_std__["a" /* update */](dt, idxBoid, neighbors, Flock.prototype.pos);
      Flock.prototype.vel[idxBoid] = v;
      // StdBoid.separate(idxBoid, Flock.prototype.neighbors[idxBoid], Flock.prototype.pos);

      // this.boids[idxBoid].move(dt);
      Flock.prototype.moveBoid(dt, idxBoid);
    }

    this.grid.add(Flock.prototype.pos);
    this.grid.findNeighbors(this.neighborDist, this.maxNeighbors, Flock.prototype);

    for (let idxBoid = 0; idxBoid < this.numActive; ++idxBoid) {
      Flock.prototype.centroid[idxBoid] = findGroupCentroid(idxBoid);
    }
  }

  function findGroupCentroid(boidId) {
    var neighbors = Flock.prototype.neighbors[boidId]
    var numNeighbors = neighbors.length;
    var bp = Flock.prototype.pos[boidId];
    var goal = [bp[0], bp[1]];
    for (var i = 0; i < numNeighbors; ++i) {
      var nid = neighbors[i];
      var np = Flock.prototype.pos[nid];

      goal[0] += np[0];
      goal[1] += np[1];
    }
    goal[0] /= numNeighbors+1;
    goal[1] /= numNeighbors+1;

    return goal;
  }

  Flock.prototype.debugDraw = function (context) {
    let numBoids = this.boids.length;
    let specialBoidId = 0;
    let skipRegularBoids = true;

    for (let idxBoid = 0; idxBoid < numBoids; ++idxBoid) {
      if (skipRegularBoids && idxBoid != specialBoidId) {
        continue;
      }

      var bp = Flock.prototype.pos[idxBoid];

      // draw neighborDist range
      Object(__WEBPACK_IMPORTED_MODULE_0__draw2d_js__["a" /* drawCircle */])(context, bp[0], bp[1], this.neighborDist, 'darkgray', 0.5);

      var neighbors = Flock.prototype.neighbors[idxBoid];
      var numNeighbors = neighbors.length;
      if (numNeighbors > 0) {
        context.strokeStyle = "red"; //"hsla(" + this.hue + ",100%,50%,1)";
        context.lineWidth = 0.5;
        context.beginPath();
        let pos = Flock.prototype.centroid[idxBoid];
        for (var i = 0; i < numNeighbors; ++i) {
          context.moveTo(pos[0], pos[1]);
          var nid = neighbors[i];
          var np = Flock.prototype.pos[nid];
          context.lineTo(np[0], np[1]);
          context.stroke();
        }

        context.moveTo(pos[0], pos[1]);
        context.lineTo(bp[0], bp[1]);
        context.stroke();

        xyz(context, pos[0], pos[1], 2, "white");
      }
    }
  }

  function xyz(context, x, y, radius, color) {
    context.beginPath();
    context.fillStyle = color;
    context.arc(x, y, radius, 0, 2*Math.PI, false);
    context.fill();
  }

  Flock.prototype.draw = function(context) {
    var numBoids = this.boids.length;
    for (var idxBoid = 0; idxBoid < numBoids; ++idxBoid) {
      this.drawBoid(context, idxBoid);
    }
  }

  return Flock;
});


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["a"] = dot;
const nearlyZero = 0.00001;
/* unused harmony export nearlyZero */


function normalize(v) {
  let lv = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
  if (Math.abs(lv) > nearlyZero) {
    v[0] /= lv;
    v[1] /= lv;
  }
  return v;
}

function dot(v1, v2) {
  return v1[0]*v2[0] + v1[1]*v2[1]
}


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class Mildo {
  constructor() {
    console.log("MILDO");
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Mildo;



/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = update;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__smu_js__ = __webpack_require__(5);


function update(dt, boidId, neighbors, positions) {
  // velocity modifiers
  var sv = separate(boidId, neighbors, positions);
  var sf = 1;

  var cv = cohere(boidId, neighbors, positions);
  var cf = 0.0;

  var av = align(boidId, neighbors, positions);
  var af = 0.8;

  var gv = gravitate();
  var gf = 0;

  var bv = [0, 0]; //Boid.prototype.vel[boidId];
  let bf = 1;

  // boid vel coefficient
  var vm = [0, 0];
  vm[0] = sf*sv[0] + cf*cv[0] + af*av[0] + gf*gv[0] + bf*bv[0];
  vm[1] = sf*sv[1] + cf*cv[1] + af*av[1] + gf*gv[1] + bf*bv[1];
  // vm = normalize(vm);

  // vm[0] += bv[0];
  // vm[1] += bv[1];
  // vm = normalize(vm);

/*
  var d = dot(bv, vm);
  var tlim = Boid.prototype.turns[boidId];
  var ts = Math.sign(tlim);
  tlim *= ts;
  if (d < Boid.prototype.rotLimit * 1) { //tlim) {
    // use the determinant to figure out which way vm points
    // this calculation is simplified due to use of the origin
    var determinant = bv[0]*vm[1] - bv[1]*vm[0];
    var side = Math.sign(determinant);
    if (side > 0) {
      if (side == ts) {
        vm = rotate(bv, Boid.prototype.rpos);
        Boid.prototype.turns[boidId] += side;
        Boid.prototype.turns[boidId] = Math.max(side, -4);
      } else {
        Boid.prototype.turns[boidId] = side;
        return;
      }
    } else {
      if (side == ts) {
        vm = rotate(bv, Boid.prototype.rneg);
        Boid.prototype.turns[boidId] += side;
        Boid.prototype.turns[boidId] = Math.min(side, 4);
      } else {
        Boid.prototype.turns[boidId] = side;
        return;
      }
    }
  }
*/
  // never allow velocity to go to zero (prevents 'freeze' glitch)
  if (Object(__WEBPACK_IMPORTED_MODULE_0__smu_js__["a" /* dot */])(vm, vm) < nearlyZero) {
    return [0, 0];
  }
  // Boid.prototype.vel[boidId] = vm;
  return vm;
}

function separate(boidId, neighbors, positions) {
  let numNeighbors = neighbors.length;
  let av = [0, 0];
  let bp = positions[boidId];
  let threshold = 100*100;
  for (let i = 0; i < numNeighbors; ++i) {
    let nid = neighbors[i];
    let np = positions[nid];

    let d = [0, 0];
    d[0] = bp[0] - np[0];
    d[1] = bp[1] - np[1];
    let ds = d[0]*d[0] + d[1]*d[1];
    if (ds < threshold) {
      // NOTE add factor to prevent divide by 0
      ds += 0.1;
      let factor = threshold / ds;
      av[0] += d[0] * factor;
      av[1] += d[1] * factor;
    }
  }
  av = Object(__WEBPACK_IMPORTED_MODULE_0__smu_js__["b" /* normalize */])(av);

  return av;
}

function cohere() {
  return [0, 0];
}

function align() {
  return [0, 0];
}

function gravitate() {
  return [0, 0];
}


/***/ }),
/* 8 */
/***/ (function(module, exports) {

//
// Simulation Math Utilities
//
// TODO FIX
// TODO this is just throwing everything into the
//      global namespace...
module.exports = (function () {
  this.nearlyZero = 0.00001;

  this.normalize = function (v) {
    let lv = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
    if (Math.abs(lv) > nearlyZero) {
      v[0] /= lv;
      v[1] /= lv;
    }
    return v;
  }

  this.dot = function(v1, v2) {
    return v1[0]*v2[0] + v1[1]*v2[1]
  }

  this.buildRotationMatrix = function(degrees) {
    var radians = degrees * Math.PI / 180.0;
    var matrix = [
      [Math.cos(radians), -Math.sin(radians)],
      [Math.sin(radians), Math.cos(radians)],
    ];
    return matrix;
  }

  this.rotate = function(v, m) {
    var x = m[0][0]*v[0] + m[0][1]*v[1]
    var y = m[1][0]*v[0] + m[1][1]*v[1]
    return [x, y];
  }

  this.randomInRange = function(min, max, wantInt) {
    var max = (max === 0 || max) ? max : 1,
        min = min || 0,
        gen = min + (max - min) * Math.random();

    return (wantInt) ? Math.round(gen) : gen;
  }

  return {
    // normalize: normalize,
    dot: dot,
    buildRotationMatrix: buildRotationMatrix,
    rotate: rotate,
    randomInRange: randomInRange
  };
})();


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOTI2ZjAzMDQyOTdjYTIxMjVhOWEiLCJ3ZWJwYWNrOi8vLy4vanMvQm9pZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9kcmF3MmQuanMiLCJ3ZWJwYWNrOi8vLy4vanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vanMvZ3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9mbG9jay5qcyIsIndlYnBhY2s6Ly8vLi9qcy9zbXUuanMiLCJ3ZWJwYWNrOi8vLy4vanMvbWlsZG8uanMiLCJ3ZWJwYWNrOi8vLy4vanMvYm9pZF9zdGQuanMiLCJ3ZWJwYWNrOi8vLy4vanMvc211Lm9yaWcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7QUM3RDhCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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cyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDkyNmYwMzA0Mjk3Y2EyMTI1YTlhIiwiaW1wb3J0IHsgZHJhd0NpcmNsZSwgZHJhd0RvdCB9IGZyb20gJy4vZHJhdzJkJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICBCb2lkLnByb3RvdHlwZS5udW1Cb2lkcyA9IDA7XG4gIEJvaWQucHJvdG90eXBlLnBvcyA9IFtdO1xuICBCb2lkLnByb3RvdHlwZS52ZWwgPSBbXTtcbiAgQm9pZC5wcm90b3R5cGUubmVpZ2hib3JzID0gW107XG4gIEJvaWQucHJvdG90eXBlLmNlbnRyb2lkID0gW107XG5cbiAgZnVuY3Rpb24gQm9pZChwb3MsIHZlbCkge1xuICAgIHRoaXMuaWQgPSBCb2lkLnByb3RvdHlwZS5udW1Cb2lkcysrO1xuICAgIEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXSA9IHBvcztcbiAgICBCb2lkLnByb3RvdHlwZS52ZWxbdGhpcy5pZF0gPSB2ZWw7XG4gICAgQm9pZC5wcm90b3R5cGUubmVpZ2hib3JzW3RoaXMuaWRdID0gW107XG4gIH1cblxuICBCb2lkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJvaWRcblxuICBCb2lkLnByb3RvdHlwZS5zZXBhcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmVpZ2hib3JzID0gQm9pZC5wcm90b3R5cGUubmVpZ2hib3JzW3RoaXMuaWRdXG4gICAgdmFyIG51bU5laWdoYm9ycyA9IG5laWdoYm9ycy5sZW5ndGg7XG4gICAgdmFyIGF2ID0gWzAsIDBdO1xuICAgIHZhciBicCA9IEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXTtcbiAgICB2YXIgdGhyZXNob2xkID0gMTAwKjEwMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5laWdoYm9yczsgKytpKSB7XG4gICAgICB2YXIgbmlkID0gbmVpZ2hib3JzW2ldO1xuICAgICAgdmFyIG5wID0gQm9pZC5wcm90b3R5cGUucG9zW25pZF07XG5cbiAgICAgIHZhciBkID0gWzAsIDBdO1xuICAgICAgZFswXSA9IGJwWzBdIC0gbnBbMF07XG4gICAgICBkWzFdID0gYnBbMV0gLSBucFsxXTtcbiAgICAgIHZhciBkcyA9IGRbMF0qZFswXSArIGRbMV0qZFsxXTtcbiAgICAgIGlmIChkcyA8IHRocmVzaG9sZCkge1xuICAgICAgICAvLyBOT1RFIGFkZCBmYWN0b3IgdG8gcHJldmVudCBkaXZpZGUgYnkgMFxuICAgICAgICBkcyArPSAwLjE7XG4gICAgICAgIHZhciBmYWN0b3IgPSB0aHJlc2hvbGQgLyBkcztcbiAgICAgICAgYXZbMF0gKz0gZFswXSAqIGZhY3RvcjtcbiAgICAgICAgYXZbMV0gKz0gZFsxXSAqIGZhY3RvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgYXYgPSBub3JtYWxpemUoYXYpO1xuXG4gICAgcmV0dXJuIGF2O1xuICB9XG5cbiAgQm9pZC5wcm90b3R5cGUuY29oZXJlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdiA9IFswLCAwXTtcbiAgICBpZiAoQm9pZC5wcm90b3R5cGUubmVpZ2hib3JzW3RoaXMuaWRdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGN2O1xuICAgIH1cblxuICAgIGdvYWwgPSBCb2lkLnByb3RvdHlwZS5jZW50cm9pZFt0aGlzLmlkXTtcbiAgICB2YXIgYnAgPSBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF07XG4gICAgY3ZbMF0gPSBnb2FsWzBdIC0gYnBbMF07XG4gICAgY3ZbMV0gPSBnb2FsWzFdIC0gYnBbMV07XG4gICAgcmV0dXJuIGN2O1xuICB9XG5cbiAgZnVuY3Rpb24gY2xhbXBlcigpIHtcblxuICB9XG5cbiAgQm9pZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGR0KSB7XG4gICAgLy8gdmVsb2NpdHkgbW9kaWZpZXJzXG4gICAgdmFyIHN2ID0gdGhpcy5zZXBhcmF0ZSgpO1xuICAgIHZhciBzZiA9IDAuMDtcblxuICAgIHZhciBjdiA9IHRoaXMuY29oZXJlKCk7XG4gICAgLy8gbGV0IGRpc3QyID0gZG90KGN2LCBjdik7XG4gICAgLy8gaWYgKGRpc3QyIDwgNCB8fCBkaXN0MiA+IDEyMCkge1xuICAgIC8vICAgY3YgPSBbMCwgMF07XG4gICAgLy8gfVxuICAgIHZhciBjZiA9IDAuMDtcblxuICAgIC8vLS0tLVxuICAgIGxldCBidmMgPSAwLjk5OTk5OTk5O1xuICAgIHZhciBidiA9IEJvaWQucHJvdG90eXBlLnZlbFt0aGlzLmlkXTtcblxuICAgIHZhciB2bSA9IFswLCAwXTtcbiAgICB2bVswXSA9IHNmKnN2WzBdICsgY2YqY3ZbMF0gKyBidmMqYnZbMF07XG4gICAgdm1bMV0gPSBzZipzdlsxXSArIGNmKmN2WzFdICsgYnZjKmJ2WzFdO1xuXG4gICAgbGV0IHZsID0gTWF0aC5zcXJ0KGRvdCh2bSwgdm0pKTtcbiAgICBpZiAodmwgPiA0KSB7XG4gICAgICB2bSA9IG5vcm1hbGl6ZSh2bSk7XG4gICAgICB2bVswXSAqPSA0O1xuICAgICAgdm1bMV0gKj0gNDtcbiAgICB9XG5cbiAgICBCb2lkLnByb3RvdHlwZS52ZWxbdGhpcy5pZF0gPSB2bTtcbiAgfVxuXG4gIEJvaWQucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoZHQpIHtcbiAgICBsZXQgdmMgPSAxO1xuICAgIEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVswXSArPSAodmMgKiBCb2lkLnByb3RvdHlwZS52ZWxbdGhpcy5pZF1bMF0pO1xuICAgIEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVsxXSArPSAodmMgKiBCb2lkLnByb3RvdHlwZS52ZWxbdGhpcy5pZF1bMV0pO1xuXG4gICAgLy8ga2VlcCBib2lkIHdpdGhpbiBsaW1pdHNcbiAgICB2YXIgd2lkdGggPSAyMDA7IC8vY29udGV4dC5jYW52YXMud2lkdGggLSAxO1xuICAgIHZhciBoZWlnaHQgPSAyMDA7IC8vY29udGV4dC5jYW52YXMuaGVpZ2h0IC0gMTtcblxuICAgIHZhciBieCA9IEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVswXTtcbiAgICBpZiAoYnggPj0gd2lkdGgpIHtcbiAgICAgIEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVswXSA9IDA7IC8vIGJ4IC0gd2lkdGg7XG4gICAgfSBlbHNlIGlmIChieCA8IDApIHtcbiAgICAgIEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVswXSA9IHdpZHRoOyAvLyBieCArIHdpZHRoO1xuICAgIH1cblxuICAgIHZhciBieSA9IEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVsxXTtcbiAgICBpZiAoYnkgPj0gaGVpZ2h0KSB7XG4gICAgICBCb2lkLnByb3RvdHlwZS5wb3NbdGhpcy5pZF1bMV0gPSAwOyAvLyBieSAtIGhlaWdodDtcbiAgICB9IGVsc2UgaWYgKGJ5IDwgMCkge1xuICAgICAgQm9pZC5wcm90b3R5cGUucG9zW3RoaXMuaWRdWzFdID0gaGVpZ2h0OyAvLyBieSArIGhlaWdodDtcbiAgICB9XG4gIH1cblxuICBCb2lkLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG5cbiAgICB2YXIgeCA9IEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVswXTtcbiAgICB2YXIgeSA9IEJvaWQucHJvdG90eXBlLnBvc1t0aGlzLmlkXVsxXTtcblxuICAgIGxldCByYWRpdXMgPSA0O1xuICAgIC8vIGRyYXdEb3QoY29udGV4dCwgeCwgeSwgcmFkaXVzLCBcIndoaXRlXCIpXG4gICAgZHJhd0NpcmNsZShjb250ZXh0LCB4LCB5LCByYWRpdXMsIFwicmVkXCIsIDAuNSk7XG4gIH1cblxuICBmdW5jdGlvbiBzYXlJdCgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkhFRUJFRSBKRUVCRUVcIik7XG4gIH1cblxuICBCb2lkLnByb3RvdHlwZS5ibGFoID0gZnVuY3Rpb24gKCkge1xuICAgIHNheUl0KCk7XG4gIH1cblxuICByZXR1cm4gQm9pZDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vanMvQm9pZC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZnVuY3Rpb24gZHJhd0NpcmNsZShjb250ZXh0LCB4LCB5LCByYWRpdXMsIGNvbG9yLCB3aWR0aCkge1xuICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjb250ZXh0Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KVxuICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIqTWF0aC5QSSwgZmFsc2UpO1xuICBjb250ZXh0LmxpbmVXaWR0aCA9IHdpZHRoO1xuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGNvbnRleHQuc3Ryb2tlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3RG90KGNvbnRleHQsIHgsIHksIHJhZGl1cywgY29sb3IpIHtcbiAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgY29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCAwLCAyKk1hdGguUEksIGZhbHNlKTtcbiAgY29udGV4dC5maWxsKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL2RyYXcyZC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBpbXBvcnQgQm9pZCBmcm9tICcuL0JvaWQnXG5pbXBvcnQgR3JpZEZ1bmN0aW9uIGZyb20gJy4vZ3JpZCc7XG5pbXBvcnQgRmxvY2tGdW5jdGlvbiBmcm9tICcuL2Zsb2NrLmpzJztcbmltcG9ydCBNaWxkbyBmcm9tICcuL21pbGRvJztcblxuY29uc3QgR3JpZCA9IEdyaWRGdW5jdGlvbigpO1xuY29uc3QgRmxvY2sgPSBGbG9ja0Z1bmN0aW9uKCk7XG5cbnZhciBmbG9ja3MgPSBbXTtcblxuLy8tLVsgc3RlcCBdLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGdsb2JhbHNcbi8vIC0gZmxvY2tzXG4vLyAtID9cbmZ1bmN0aW9uIHN0ZXAodGltZXN0YW1wKSB7XG4gIGxldCBmcmFtZVRpbWVNcyA9IHRpbWVzdGFtcCAtIGxhc3Q7XG4gIGxhc3QgPSB0aW1lc3RhbXA7XG4gIC8vIGNvbnNvbGUubG9nKGZyYW1lVGltZU1zKTtcblxuICAvLyBmcmFtZXMgcGVyIHNlY29uZFxuICBsZXQgZWxhcHNlZFRpbWUgPSAodGltZXN0YW1wIC0gc3RhcnRUaW1lKSAvIDEwMDAsXG4gIHJlc3VsdCA9IE1hdGguZmxvb3IoKGZyYW1lIC8gZWxhcHNlZFRpbWUpKTtcbiAgaWYgKGVsYXBzZWRUaW1lID4gMSkge1xuICAgIHN0YXJ0VGltZSA9IHRpbWVzdGFtcDtcbiAgICBmcmFtZSA9IDA7XG4gIH1cbiAgaWYgKGZyYW1lICUgMTAgPT0gMCkge1xuICAgIGxldCBmcHNUZXh0ID0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgLy8gY29uc29sZS5sb2coZnBzVGV4dCk7XG4gIH1cbiAgKytmcmFtZTtcblxuICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gIGlmIChmcmFtZSAlIDMgPT09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZmxvY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBmbG9ja3NbaV0udXBkYXRlKHRpbWVzdGFtcCk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbG9ja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBmbG9ja3NbaV0uc3Bhd24oMCk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZsb2Nrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGZsb2Nrc1tpXS5kZWJ1Z0RyYXcoY29udGV4dCk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZsb2Nrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGZsb2Nrc1tpXS5kcmF3KGNvbnRleHQpO1xuICB9XG5cbiAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBsYXN0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG52YXIgc3RhcnRUaW1lID0gbGFzdDtcbnZhciBmcmFtZSA9IDA7XG5cbmxldCBtID0gbmV3IE1pbGRvKCk7XG5cbmxldCB3dyA9IHdpbmRvdy5pbm5lcldpZHRoO1xubGV0IHdoID0gd2luZG93LmlubmVySGVpZ2h0O1xudmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaWVsZCcpO1xudmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbmNvbnRleHQuY2FudmFzLndpZHRoID0gd3c7XG5jb250ZXh0LmNhbnZhcy5oZWlnaHQgPSB3aDtcblxubGV0IGcgPSBuZXcgR3JpZCh3dywgd2gsIDEwMCk7XG5mbG9ja3MucHVzaChuZXcgRmxvY2soZykpO1xuZmxvY2tzWzBdLmNyZWF0ZUJvaWRzKDMpO1xuLy9mLmNyZWF0ZVNvdXJjZSh3dyAvIDIsIHdoIC8gMik7XG5mbG9ja3NbMF0uY3JlYXRlU291cmNlKDI1LCAyNSk7XG5cbmxldCB4ID0gbmV3IEZsb2NrKGcpO1xueC5jcmVhdGVCb2lkcygxKTtcbnguY3JlYXRlU291cmNlKDc1LCA3NSk7XG5cbndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBCb2lkRnVuY3Rpb24gZnJvbSAnLi9Cb2lkLmpzJztcblxuY29uc3QgQm9pZCA9IEJvaWRGdW5jdGlvbigpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gIC8vIG1vdmUgdG8gcmVzZXQgZm4/XG4gIEdyaWQucHJvdG90eXBlLndpZHRoID0gMDtcbiAgR3JpZC5wcm90b3R5cGUuaGVpZ2h0ID0gMDtcbiAgR3JpZC5wcm90b3R5cGUuY3ggPSAwO1xuICBHcmlkLnByb3RvdHlwZS5jeSA9IDA7XG4gIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0gPSAwO1xuICBHcmlkLnByb3RvdHlwZS5maWVsZCA9IFtdO1xuXG4gIGZ1bmN0aW9uIEdyaWQod2lkdGgsIGhlaWdodCwgbWluQ2VsbERpbSkge1xuICAgIC8vIHhcbiAgICBHcmlkLnByb3RvdHlwZS53aWR0aCA9IHdpZHRoO1xuICAgIEdyaWQucHJvdG90eXBlLmN4ID0gTWF0aC5jZWlsKHdpZHRoIC8gbWluQ2VsbERpbSk7XG5cbiAgICAvLyB5XG4gICAgR3JpZC5wcm90b3R5cGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIEdyaWQucHJvdG90eXBlLmN5ID0gTWF0aC5jZWlsKGhlaWdodCAvIG1pbkNlbGxEaW0pO1xuXG4gICAgR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSA9IG1pbkNlbGxEaW07XG5cbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IEdyaWQucHJvdG90eXBlLmN4OyArK3gpIHtcbiAgICAgIEdyaWQucHJvdG90eXBlLmZpZWxkW3hdID0gW11cbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgR3JpZC5wcm90b3R5cGUuY3k7ICsreSkge1xuICAgICAgICBHcmlkLnByb3RvdHlwZS5maWVsZFt4XS5wdXNoKFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZW5kaXQgPSAwO1xuICB9XG5cbiAgR3JpZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmlkO1xuXG4gIEdyaWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgIC8vIGNsZWFyIHRoZSBncmlkXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBHcmlkLnByb3RvdHlwZS5maWVsZC5sZW5ndGg7ICsreCkge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBHcmlkLnByb3RvdHlwZS5maWVsZFswXS5sZW5ndGg7ICsreSkge1xuICAgICAgICBHcmlkLnByb3RvdHlwZS5maWVsZFt4XVt5XSA9IFtdXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZG8gdGhlIGFkZGluZ1xuICAgIHZhciBudW1Qb3NpdGlvbnMgPSBwb3NpdGlvbnMubGVuZ3RoO1xuICAgIGZvciAodmFyIGlkeFBvcyA9IDA7IGlkeFBvcyA8IG51bVBvc2l0aW9uczsgKytpZHhQb3MpIHtcbiAgICAgIHZhciBicCA9IHBvc2l0aW9uc1tpZHhQb3NdO1xuICAgICAgdmFyIHhjID0gTWF0aC5mbG9vcihicFswXSAvIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0pO1xuICAgICAgdmFyIHljID0gTWF0aC5mbG9vcihicFsxXSAvIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0pO1xuICAgICAgaWYgKEdyaWQucHJvdG90eXBlLmZpZWxkW3hjXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBicmVha19oZXJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIEdyaWQucHJvdG90eXBlLmZpZWxkW3hjXVt5Y10ucHVzaChpZHhQb3MpO1xuICAgICAgLy8gY29sb3IgYm9pZHMgYmFzZWQgb24gcG9zaXRpb25cbiAgICAgIC8vIEJvaWQucHJvdG90eXBlLmh1ZVtpZHhQb3NdID0gKCh5YyArIHhjKSAlIDIpID09IDAgPyBcImJsdWVcIiA6IFwiZ3JlZW5cIlxuICAgIH1cblxuICAgIC8vIHNhdmUgdGhlIHBvc2l0aW9ucyBmb3IgdGhlIHF1ZXJpZXNcbiAgICBHcmlkLnByb3RvdHlwZS5wb3NpdGlvbnMgPSBwb3NpdGlvbnM7XG4gIH1cblxuICBHcmlkLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKG14LCBteSkge1xuICAgIHZhciB4YyA9IE1hdGguZmxvb3IobXggLyBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltKTtcbiAgICB2YXIgeWMgPSBNYXRoLmZsb29yKG15IC8gR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSk7XG5cbiAgICB2YXIgc2VsZWN0ZWRJRCA9IG51bGw7XG4gICAgdmFyIG1pblRvQm9pZFNxciA9IEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0gKiBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltO1xuICAgIHZhciBjYW5kaWRhdGVzID0gR3JpZC5wcm90b3R5cGUuZmllbGRbeGNdW3ljXTtcbiAgICB2YXIgbnVtQ2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGlkeENhbmRpZGF0ZSA9IDA7IGlkeENhbmRpZGF0ZSA8IG51bUNhbmRpZGF0ZXM7ICsraWR4Q2FuZGlkYXRlKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlSUQgPSBjYW5kaWRhdGVzW2lkeENhbmRpZGF0ZV07XG4gICAgICB2YXIgcG9zID0gR3JpZC5wcm90b3R5cGUucG9zaXRpb25zW2NhbmRpZGF0ZUlEXTtcbiAgICAgIHZhciBkeCA9IHBvc1swXSAtIG14O1xuICAgICAgdmFyIGR5ID0gcG9zWzFdIC0gbXk7XG4gICAgICB2YXIgdG9Cb2lkU3FyID0gZHgqZHggKyBkeSpkeTtcbiAgICAgIGlmICh0b0JvaWRTcXIgPCAxMjEgJiYgdG9Cb2lkU3FyIDwgbWluVG9Cb2lkU3FyKSB7XG4gICAgICAgIHNlbGVjdGVkSUQgPSBjYW5kaWRhdGVJRDtcbiAgICAgICAgbWluVG9Cb2lkU3FyID0gdG9Cb2lkU3FyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3RlZElEO1xuICB9XG5cbiAgLy8gTk9URSBwcm90b3R5cGUgaXMgYW4gT1VUIHZhcmlhYmxlIChtb2RpZmllZCB3aXRoaW4gdGhpcyBmbilcbiAgR3JpZC5wcm90b3R5cGUuZmluZE5laWdoYm9ycyA9IGZ1bmN0aW9uKHRocmVzaG9sZCwgbWF4TmVpZ2hib3JzLCBwcm90b3R5cGUpIHtcbiAgICB2YXIgc2NhbGVGYWN0b3IgPSAxMDAwO1xuICAgIHZhciBudW1Cb2lkcyA9IHByb3RvdHlwZS5udW1Cb2lkcztcblxuICAgIGZvciAodmFyIGlkeEJvaWQgPSAwOyBpZHhCb2lkIDwgbnVtQm9pZHM7ICsraWR4Qm9pZCkge1xuICAgICAgdmFyIGJwID0gcHJvdG90eXBlLnBvc1tpZHhCb2lkXTtcbiAgICAgIHZhciBxeCA9IGJwWzBdO1xuICAgICAgdmFyIHF5ID0gYnBbMV07XG5cbiAgICAgIHZhciB4MCA9IE1hdGguZmxvb3IoKHF4IC0gdGhyZXNob2xkKSAvIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0pO1xuICAgICAgeDAgPSBNYXRoLm1heCgwLCB4MCk7XG4gICAgICB2YXIgeDEgPSBNYXRoLmZsb29yKChxeCArIHRocmVzaG9sZCkgLyBHcmlkLnByb3RvdHlwZS5taW5DZWxsRGltKTtcbiAgICAgIHgxID0gTWF0aC5taW4oR3JpZC5wcm90b3R5cGUuZmllbGQubGVuZ3RoIC0gMSwgeDEpO1xuICAgICAgdmFyIHkwID0gTWF0aC5mbG9vcigocXkgLSB0aHJlc2hvbGQpIC8gR3JpZC5wcm90b3R5cGUubWluQ2VsbERpbSk7XG4gICAgICB5MCA9IE1hdGgubWF4KDAsIHkwKTtcbiAgICAgIHZhciB5MSA9IE1hdGguZmxvb3IoKHF5ICsgdGhyZXNob2xkKSAvIEdyaWQucHJvdG90eXBlLm1pbkNlbGxEaW0pO1xuICAgICAgeTEgPSBNYXRoLm1pbihHcmlkLnByb3RvdHlwZS5maWVsZFswXS5sZW5ndGggLSAxLCB5MSk7XG5cbiAgICAgIHZhciBjYW5kaWRhdGVzID0gW107XG4gICAgICBmb3IgKHZhciB4ID0geDA7IHggPD0geDE7ICsreCkge1xuICAgICAgICBmb3IgKHZhciB5ID0geTA7IHkgPD0geTE7ICsreSkge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaC5hcHBseShjYW5kaWRhdGVzLCBHcmlkLnByb3RvdHlwZS5maWVsZFt4XVt5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5laWdoYm9ycyA9IFtdO1xuICAgICAgdmFyIHRzcXIgPSB0aHJlc2hvbGQgKiB0aHJlc2hvbGQ7XG4gICAgICB2YXIgbnVtQ2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaWR4Q2FuZGlkYXRlID0gMDsgaWR4Q2FuZGlkYXRlIDwgbnVtQ2FuZGlkYXRlczsgKytpZHhDYW5kaWRhdGUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZUlEID0gY2FuZGlkYXRlc1tpZHhDYW5kaWRhdGVdO1xuICAgICAgICB2YXIgY3BvcyA9IEdyaWQucHJvdG90eXBlLnBvc2l0aW9uc1tjYW5kaWRhdGVJRF07XG4gICAgICAgIHZhciBkeCA9IGNwb3NbMF0gLSBxeDtcbiAgICAgICAgdmFyIGR5ID0gY3Bvc1sxXSAtIHF5O1xuICAgICAgICB2YXIgZHNxciA9IGR4KmR4ICsgZHkqZHk7XG4gICAgICAgIGlmIChkc3FyIDw9IHRzcXIgJiYgZHNxciA+IG5lYXJseVplcm8pIHtcbiAgICAgICAgICBuZWlnaGJvcnMucHVzaChNYXRoLmNlaWwoZHNxcikgKiBzY2FsZUZhY3RvciArIGNhbmRpZGF0ZUlEKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gc29ydCBuZWlnaGJvcnMgdG8gZ2V0IHRoZSBjbG9zZXN0XG4gICAgICBuZWlnaGJvcnMgPSBuZWlnaGJvcnMuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLWJ9KTtcbiAgICAgIG5laWdoYm9ycyA9IG5laWdoYm9ycy5zbGljZSgwLCBtYXhOZWlnaGJvcnMpO1xuICAgICAgLy8gc3RyaXAgb2ZmIHRoZSBwb3NpdGlvbiBpbmZvIHRvIGxlYXZlIHRoZSBJRHNcbiAgICAgIHByb3RvdHlwZS5uZWlnaGJvcnNbaWR4Qm9pZF0gPSBuZWlnaGJvcnMubWFwKGZ1bmN0aW9uKHgpe3JldHVybiB4ICUgc2NhbGVGYWN0b3J9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gR3JpZDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vanMvZ3JpZC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKCcuL3NtdS5vcmlnLmpzJyk7XG5pbXBvcnQgeyBkcmF3Q2lyY2xlIH0gZnJvbSAnLi9kcmF3MmQuanMnO1xuaW1wb3J0IEJvaWRGdW5jdGlvbiBmcm9tICcuL0JvaWQuanMnO1xuaW1wb3J0ICogYXMgU3RkQm9pZCBmcm9tICcuL2JvaWRfc3RkJ1xuXG5jb25zdCBCb2lkID0gQm9pZEZ1bmN0aW9uKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgRmxvY2sucHJvdG90eXBlLm51bUZsb2NrcyA9IDA7XG4gIEZsb2NrLnByb3RvdHlwZS5udW1Cb2lkcyA9IDA7XG4gIEZsb2NrLnByb3RvdHlwZS5wb3MgPSBbXTtcbiAgRmxvY2sucHJvdG90eXBlLnZlbCA9IFtdO1xuICBGbG9jay5wcm90b3R5cGUubmVpZ2hib3JzID0gW107XG4gIEZsb2NrLnByb3RvdHlwZS5jZW50cm9pZCA9IFtdO1xuXG4gIEZsb2NrLnByb3RvdHlwZS5zb3VyY2VzID0gW107XG5cbiAgZnVuY3Rpb24gRmxvY2soZ3JpZCkge1xuICAgIHRoaXMuaWQgPSBGbG9jay5wcm90b3R5cGUubnVtRmxvY2tzKys7XG4gICAgdGhpcy5ncmlkID0gZ3JpZDtcbiAgICB0aGlzLm51bUFjdGl2ZSA9IDA7XG4gICAgdGhpcy5ib2lkcyA9IFtdO1xuICAgIHRoaXMubmVpZ2hib3JEaXN0ID0gNzU7XG4gICAgdGhpcy5tYXhOZWlnaGJvcnMgPSAxMDtcbiAgfVxuXG4gIEZsb2NrLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZsb2NrXG5cbiAgRmxvY2sucHJvdG90eXBlLmNyZWF0ZUJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbnVtU291cmNlcyA9IEZsb2NrLnByb3RvdHlwZS5zb3VyY2VzLmxlbmd0aDtcbiAgICB2YXIgaWR4U291cmNlID0gcmFuZG9tSW5SYW5nZSgwLCBudW1Tb3VyY2VzIC0gMSwgdHJ1ZSk7XG4gICAgdmFyIHNyYyA9IEZsb2NrLnByb3RvdHlwZS5zb3VyY2VzW2lkeFNvdXJjZV07XG4gICAgdmFyIHAgPSBbc3JjWzBdLCBzcmNbMV1dO1xuICAgIHBbMF0gKz0gTWF0aC5yYW5kb20oKSAqIDYgLSAzO1xuICAgIHBbMV0gKz0gTWF0aC5yYW5kb20oKSAqIDYgLSAzO1xuXG4gICAgLy8gc2V0IHZlbG9jaXR5IChha2EgaGVhZGluZylcbiAgICB2YXIgdiA9IFsoTWF0aC5yYW5kb20oKSAtIDAuNSksIChNYXRoLnJhbmRvbSgpIC0gMC41KV07XG4gICAgdiA9IG5vcm1hbGl6ZSh2KTtcblxuICAgIGxldCBib2lkSWQgPSBGbG9jay5wcm90b3R5cGUubnVtQm9pZHMrKztcbiAgICBGbG9jay5wcm90b3R5cGUucG9zW2JvaWRJZF0gPSBwO1xuICAgIEZsb2NrLnByb3RvdHlwZS52ZWxbYm9pZElkXSA9IHY7XG4gICAgRmxvY2sucHJvdG90eXBlLm5laWdoYm9yc1tib2lkSWRdID0gW107XG5cbiAgICByZXR1cm4gYm9pZElkO1xuICB9XG5cbiAgRmxvY2sucHJvdG90eXBlLm1vdmVCb2lkID0gZnVuY3Rpb24gKGR0LCBib2lkSWQpIHtcbiAgICBsZXQgdmMgPSAxO1xuICAgIEZsb2NrLnByb3RvdHlwZS5wb3NbYm9pZElkXVswXSArPSAodmMgKiBGbG9jay5wcm90b3R5cGUudmVsW2JvaWRJZF1bMF0pO1xuICAgIEZsb2NrLnByb3RvdHlwZS5wb3NbYm9pZElkXVsxXSArPSAodmMgKiBGbG9jay5wcm90b3R5cGUudmVsW2JvaWRJZF1bMV0pO1xuXG4gICAgLy8ga2VlcCBib2lkIHdpdGhpbiBsaW1pdHNcbiAgICB2YXIgd2lkdGggPSAyMDA7IC8vY29udGV4dC5jYW52YXMud2lkdGggLSAxO1xuICAgIHZhciBoZWlnaHQgPSAyMDA7IC8vY29udGV4dC5jYW52YXMuaGVpZ2h0IC0gMTtcblxuICAgIHZhciBieCA9IEZsb2NrLnByb3RvdHlwZS5wb3NbYm9pZElkXVswXTtcbiAgICBpZiAoYnggPj0gd2lkdGgpIHtcbiAgICAgIEZsb2NrLnByb3RvdHlwZS5wb3NbYm9pZElkXVswXSA9IDA7IC8vIGJ4IC0gd2lkdGg7XG4gICAgfSBlbHNlIGlmIChieCA8IDApIHtcbiAgICAgIEZsb2NrLnByb3RvdHlwZS5wb3NbYm9pZElkXVswXSA9IHdpZHRoOyAvLyBieCArIHdpZHRoO1xuICAgIH1cblxuICAgIHZhciBieSA9IEZsb2NrLnByb3RvdHlwZS5wb3NbYm9pZElkXVsxXTtcbiAgICBpZiAoYnkgPj0gaGVpZ2h0KSB7XG4gICAgICBGbG9jay5wcm90b3R5cGUucG9zW2JvaWRJZF1bMV0gPSAwOyAvLyBieSAtIGhlaWdodDtcbiAgICB9IGVsc2UgaWYgKGJ5IDwgMCkge1xuICAgICAgRmxvY2sucHJvdG90eXBlLnBvc1tib2lkSWRdWzFdID0gaGVpZ2h0OyAvLyBieSArIGhlaWdodDtcbiAgICB9XG4gIH1cblxuICBGbG9jay5wcm90b3R5cGUuZHJhd0JvaWQgPSBmdW5jdGlvbiAoY29udGV4dCwgYm9pZElkKSB7XG4gICAgdmFyIHggPSBGbG9jay5wcm90b3R5cGUucG9zW2JvaWRJZF1bMF07XG4gICAgdmFyIHkgPSBGbG9jay5wcm90b3R5cGUucG9zW2JvaWRJZF1bMV07XG5cbiAgICBsZXQgcmFkaXVzID0gNDtcbiAgICAvLyBkcmF3RG90KGNvbnRleHQsIHgsIHksIHJhZGl1cywgXCJ3aGl0ZVwiKVxuICAgIGRyYXdDaXJjbGUoY29udGV4dCwgeCwgeSwgcmFkaXVzLCBcInJlZFwiLCAwLjUpO1xuICB9XG5cbiAgRmxvY2sucHJvdG90eXBlLmNyZWF0ZVNvdXJjZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgbGV0IG5leHRTb3VyY2VJZHggPSBGbG9jay5wcm90b3R5cGUuc291cmNlcy5sZW5ndGg7XG4gICAgRmxvY2sucHJvdG90eXBlLnNvdXJjZXNbbmV4dFNvdXJjZUlkeF0gPSBbeCwgeV07XG4gIH1cblxuICBGbG9jay5wcm90b3R5cGUuY3JlYXRlQm9pZHMgPSBmdW5jdGlvbiAobnVtQm9pZHMpIHtcbiAgICB0aGlzLm51bURlc2lyZWQgPSBudW1Cb2lkcztcbiAgfVxuXG4gIEZsb2NrLnByb3RvdHlwZS5zcGF3biA9IGZ1bmN0aW9uIChkdCkge1xuICAgIHZhciBudW1Cb2lkcyA9IHRoaXMuYm9pZHMubGVuZ3RoO1xuICAgIHRoaXMubnVtQWN0aXZlID0gTWF0aC5taW4obnVtQm9pZHMsIHRoaXMubnVtQWN0aXZlKTtcbiAgICBpZiAodGhpcy5udW1BY3RpdmUgPCB0aGlzLm51bURlc2lyZWQpIHtcbiAgICAgICsrdGhpcy5udW1BY3RpdmU7XG4gICAgICBpZiAodGhpcy5udW1BY3RpdmUgPiBudW1Cb2lkcykge1xuICAgICAgICB0aGlzLmJvaWRzW251bUJvaWRzXSA9IEZsb2NrLnByb3RvdHlwZS5jcmVhdGVCb2lkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgRmxvY2sucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkdCkge1xuICAgIGZvciAobGV0IGlkeEJvaWQgPSAwOyBpZHhCb2lkIDwgdGhpcy5udW1BY3RpdmU7ICsraWR4Qm9pZCkge1xuICAgICAgLy8gdGhpcy5ib2lkc1tpZHhCb2lkXS51cGRhdGUoZHQpO1xuICAgICAgbGV0IG5laWdoYm9ycyA9IEZsb2NrLnByb3RvdHlwZS5uZWlnaGJvcnNbaWR4Qm9pZF07XG4gICAgICBsZXQgdiA9IFN0ZEJvaWQudXBkYXRlKGR0LCBpZHhCb2lkLCBuZWlnaGJvcnMsIEZsb2NrLnByb3RvdHlwZS5wb3MpO1xuICAgICAgRmxvY2sucHJvdG90eXBlLnZlbFtpZHhCb2lkXSA9IHY7XG4gICAgICAvLyBTdGRCb2lkLnNlcGFyYXRlKGlkeEJvaWQsIEZsb2NrLnByb3RvdHlwZS5uZWlnaGJvcnNbaWR4Qm9pZF0sIEZsb2NrLnByb3RvdHlwZS5wb3MpO1xuXG4gICAgICAvLyB0aGlzLmJvaWRzW2lkeEJvaWRdLm1vdmUoZHQpO1xuICAgICAgRmxvY2sucHJvdG90eXBlLm1vdmVCb2lkKGR0LCBpZHhCb2lkKTtcbiAgICB9XG5cbiAgICB0aGlzLmdyaWQuYWRkKEZsb2NrLnByb3RvdHlwZS5wb3MpO1xuICAgIHRoaXMuZ3JpZC5maW5kTmVpZ2hib3JzKHRoaXMubmVpZ2hib3JEaXN0LCB0aGlzLm1heE5laWdoYm9ycywgRmxvY2sucHJvdG90eXBlKTtcblxuICAgIGZvciAobGV0IGlkeEJvaWQgPSAwOyBpZHhCb2lkIDwgdGhpcy5udW1BY3RpdmU7ICsraWR4Qm9pZCkge1xuICAgICAgRmxvY2sucHJvdG90eXBlLmNlbnRyb2lkW2lkeEJvaWRdID0gZmluZEdyb3VwQ2VudHJvaWQoaWR4Qm9pZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZEdyb3VwQ2VudHJvaWQoYm9pZElkKSB7XG4gICAgdmFyIG5laWdoYm9ycyA9IEZsb2NrLnByb3RvdHlwZS5uZWlnaGJvcnNbYm9pZElkXVxuICAgIHZhciBudW1OZWlnaGJvcnMgPSBuZWlnaGJvcnMubGVuZ3RoO1xuICAgIHZhciBicCA9IEZsb2NrLnByb3RvdHlwZS5wb3NbYm9pZElkXTtcbiAgICB2YXIgZ29hbCA9IFticFswXSwgYnBbMV1dO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTmVpZ2hib3JzOyArK2kpIHtcbiAgICAgIHZhciBuaWQgPSBuZWlnaGJvcnNbaV07XG4gICAgICB2YXIgbnAgPSBGbG9jay5wcm90b3R5cGUucG9zW25pZF07XG5cbiAgICAgIGdvYWxbMF0gKz0gbnBbMF07XG4gICAgICBnb2FsWzFdICs9IG5wWzFdO1xuICAgIH1cbiAgICBnb2FsWzBdIC89IG51bU5laWdoYm9ycysxO1xuICAgIGdvYWxbMV0gLz0gbnVtTmVpZ2hib3JzKzE7XG5cbiAgICByZXR1cm4gZ29hbDtcbiAgfVxuXG4gIEZsb2NrLnByb3RvdHlwZS5kZWJ1Z0RyYXcgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGxldCBudW1Cb2lkcyA9IHRoaXMuYm9pZHMubGVuZ3RoO1xuICAgIGxldCBzcGVjaWFsQm9pZElkID0gMDtcbiAgICBsZXQgc2tpcFJlZ3VsYXJCb2lkcyA9IHRydWU7XG5cbiAgICBmb3IgKGxldCBpZHhCb2lkID0gMDsgaWR4Qm9pZCA8IG51bUJvaWRzOyArK2lkeEJvaWQpIHtcbiAgICAgIGlmIChza2lwUmVndWxhckJvaWRzICYmIGlkeEJvaWQgIT0gc3BlY2lhbEJvaWRJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJwID0gRmxvY2sucHJvdG90eXBlLnBvc1tpZHhCb2lkXTtcblxuICAgICAgLy8gZHJhdyBuZWlnaGJvckRpc3QgcmFuZ2VcbiAgICAgIGRyYXdDaXJjbGUoY29udGV4dCwgYnBbMF0sIGJwWzFdLCB0aGlzLm5laWdoYm9yRGlzdCwgJ2RhcmtncmF5JywgMC41KTtcblxuICAgICAgdmFyIG5laWdoYm9ycyA9IEZsb2NrLnByb3RvdHlwZS5uZWlnaGJvcnNbaWR4Qm9pZF07XG4gICAgICB2YXIgbnVtTmVpZ2hib3JzID0gbmVpZ2hib3JzLmxlbmd0aDtcbiAgICAgIGlmIChudW1OZWlnaGJvcnMgPiAwKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcInJlZFwiOyAvL1wiaHNsYShcIiArIHRoaXMuaHVlICsgXCIsMTAwJSw1MCUsMSlcIjtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAwLjU7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGxldCBwb3MgPSBGbG9jay5wcm90b3R5cGUuY2VudHJvaWRbaWR4Qm9pZF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTmVpZ2hib3JzOyArK2kpIHtcbiAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb3NbMF0sIHBvc1sxXSk7XG4gICAgICAgICAgdmFyIG5pZCA9IG5laWdoYm9yc1tpXTtcbiAgICAgICAgICB2YXIgbnAgPSBGbG9jay5wcm90b3R5cGUucG9zW25pZF07XG4gICAgICAgICAgY29udGV4dC5saW5lVG8obnBbMF0sIG5wWzFdKTtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocG9zWzBdLCBwb3NbMV0pO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhicFswXSwgYnBbMV0pO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuXG4gICAgICAgIHh5eihjb250ZXh0LCBwb3NbMF0sIHBvc1sxXSwgMiwgXCJ3aGl0ZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB4eXooY29udGV4dCwgeCwgeSwgcmFkaXVzLCBjb2xvcikge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIqTWF0aC5QSSwgZmFsc2UpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG5cbiAgRmxvY2sucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIG51bUJvaWRzID0gdGhpcy5ib2lkcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaWR4Qm9pZCA9IDA7IGlkeEJvaWQgPCBudW1Cb2lkczsgKytpZHhCb2lkKSB7XG4gICAgICB0aGlzLmRyYXdCb2lkKGNvbnRleHQsIGlkeEJvaWQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBGbG9jaztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vanMvZmxvY2suanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGNvbnN0IG5lYXJseVplcm8gPSAwLjAwMDAxO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHYpIHtcbiAgbGV0IGx2ID0gTWF0aC5zcXJ0KHZbMF0qdlswXSArIHZbMV0qdlsxXSk7XG4gIGlmIChNYXRoLmFicyhsdikgPiBuZWFybHlaZXJvKSB7XG4gICAgdlswXSAvPSBsdjtcbiAgICB2WzFdIC89IGx2O1xuICB9XG4gIHJldHVybiB2O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZG90KHYxLCB2Mikge1xuICByZXR1cm4gdjFbMF0qdjJbMF0gKyB2MVsxXSp2MlsxXVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9zbXUuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWlsZG8ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZyhcIk1JTERPXCIpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL21pbGRvLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IG5vcm1hbGl6ZSwgZG90IH0gZnJvbSAnLi9zbXUuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlKGR0LCBib2lkSWQsIG5laWdoYm9ycywgcG9zaXRpb25zKSB7XG4gIC8vIHZlbG9jaXR5IG1vZGlmaWVyc1xuICB2YXIgc3YgPSBzZXBhcmF0ZShib2lkSWQsIG5laWdoYm9ycywgcG9zaXRpb25zKTtcbiAgdmFyIHNmID0gMTtcblxuICB2YXIgY3YgPSBjb2hlcmUoYm9pZElkLCBuZWlnaGJvcnMsIHBvc2l0aW9ucyk7XG4gIHZhciBjZiA9IDAuMDtcblxuICB2YXIgYXYgPSBhbGlnbihib2lkSWQsIG5laWdoYm9ycywgcG9zaXRpb25zKTtcbiAgdmFyIGFmID0gMC44O1xuXG4gIHZhciBndiA9IGdyYXZpdGF0ZSgpO1xuICB2YXIgZ2YgPSAwO1xuXG4gIHZhciBidiA9IFswLCAwXTsgLy9Cb2lkLnByb3RvdHlwZS52ZWxbYm9pZElkXTtcbiAgbGV0IGJmID0gMTtcblxuICAvLyBib2lkIHZlbCBjb2VmZmljaWVudFxuICB2YXIgdm0gPSBbMCwgMF07XG4gIHZtWzBdID0gc2Yqc3ZbMF0gKyBjZipjdlswXSArIGFmKmF2WzBdICsgZ2YqZ3ZbMF0gKyBiZipidlswXTtcbiAgdm1bMV0gPSBzZipzdlsxXSArIGNmKmN2WzFdICsgYWYqYXZbMV0gKyBnZipndlsxXSArIGJmKmJ2WzFdO1xuICAvLyB2bSA9IG5vcm1hbGl6ZSh2bSk7XG5cbiAgLy8gdm1bMF0gKz0gYnZbMF07XG4gIC8vIHZtWzFdICs9IGJ2WzFdO1xuICAvLyB2bSA9IG5vcm1hbGl6ZSh2bSk7XG5cbi8qXG4gIHZhciBkID0gZG90KGJ2LCB2bSk7XG4gIHZhciB0bGltID0gQm9pZC5wcm90b3R5cGUudHVybnNbYm9pZElkXTtcbiAgdmFyIHRzID0gTWF0aC5zaWduKHRsaW0pO1xuICB0bGltICo9IHRzO1xuICBpZiAoZCA8IEJvaWQucHJvdG90eXBlLnJvdExpbWl0ICogMSkgeyAvL3RsaW0pIHtcbiAgICAvLyB1c2UgdGhlIGRldGVybWluYW50IHRvIGZpZ3VyZSBvdXQgd2hpY2ggd2F5IHZtIHBvaW50c1xuICAgIC8vIHRoaXMgY2FsY3VsYXRpb24gaXMgc2ltcGxpZmllZCBkdWUgdG8gdXNlIG9mIHRoZSBvcmlnaW5cbiAgICB2YXIgZGV0ZXJtaW5hbnQgPSBidlswXSp2bVsxXSAtIGJ2WzFdKnZtWzBdO1xuICAgIHZhciBzaWRlID0gTWF0aC5zaWduKGRldGVybWluYW50KTtcbiAgICBpZiAoc2lkZSA+IDApIHtcbiAgICAgIGlmIChzaWRlID09IHRzKSB7XG4gICAgICAgIHZtID0gcm90YXRlKGJ2LCBCb2lkLnByb3RvdHlwZS5ycG9zKTtcbiAgICAgICAgQm9pZC5wcm90b3R5cGUudHVybnNbYm9pZElkXSArPSBzaWRlO1xuICAgICAgICBCb2lkLnByb3RvdHlwZS50dXJuc1tib2lkSWRdID0gTWF0aC5tYXgoc2lkZSwgLTQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQm9pZC5wcm90b3R5cGUudHVybnNbYm9pZElkXSA9IHNpZGU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNpZGUgPT0gdHMpIHtcbiAgICAgICAgdm0gPSByb3RhdGUoYnYsIEJvaWQucHJvdG90eXBlLnJuZWcpO1xuICAgICAgICBCb2lkLnByb3RvdHlwZS50dXJuc1tib2lkSWRdICs9IHNpZGU7XG4gICAgICAgIEJvaWQucHJvdG90eXBlLnR1cm5zW2JvaWRJZF0gPSBNYXRoLm1pbihzaWRlLCA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEJvaWQucHJvdG90eXBlLnR1cm5zW2JvaWRJZF0gPSBzaWRlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4qL1xuICAvLyBuZXZlciBhbGxvdyB2ZWxvY2l0eSB0byBnbyB0byB6ZXJvIChwcmV2ZW50cyAnZnJlZXplJyBnbGl0Y2gpXG4gIGlmIChkb3Qodm0sIHZtKSA8IG5lYXJseVplcm8pIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIC8vIEJvaWQucHJvdG90eXBlLnZlbFtib2lkSWRdID0gdm07XG4gIHJldHVybiB2bTtcbn1cblxuZnVuY3Rpb24gc2VwYXJhdGUoYm9pZElkLCBuZWlnaGJvcnMsIHBvc2l0aW9ucykge1xuICBsZXQgbnVtTmVpZ2hib3JzID0gbmVpZ2hib3JzLmxlbmd0aDtcbiAgbGV0IGF2ID0gWzAsIDBdO1xuICBsZXQgYnAgPSBwb3NpdGlvbnNbYm9pZElkXTtcbiAgbGV0IHRocmVzaG9sZCA9IDEwMCoxMDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTmVpZ2hib3JzOyArK2kpIHtcbiAgICBsZXQgbmlkID0gbmVpZ2hib3JzW2ldO1xuICAgIGxldCBucCA9IHBvc2l0aW9uc1tuaWRdO1xuXG4gICAgbGV0IGQgPSBbMCwgMF07XG4gICAgZFswXSA9IGJwWzBdIC0gbnBbMF07XG4gICAgZFsxXSA9IGJwWzFdIC0gbnBbMV07XG4gICAgbGV0IGRzID0gZFswXSpkWzBdICsgZFsxXSpkWzFdO1xuICAgIGlmIChkcyA8IHRocmVzaG9sZCkge1xuICAgICAgLy8gTk9URSBhZGQgZmFjdG9yIHRvIHByZXZlbnQgZGl2aWRlIGJ5IDBcbiAgICAgIGRzICs9IDAuMTtcbiAgICAgIGxldCBmYWN0b3IgPSB0aHJlc2hvbGQgLyBkcztcbiAgICAgIGF2WzBdICs9IGRbMF0gKiBmYWN0b3I7XG4gICAgICBhdlsxXSArPSBkWzFdICogZmFjdG9yO1xuICAgIH1cbiAgfVxuICBhdiA9IG5vcm1hbGl6ZShhdik7XG5cbiAgcmV0dXJuIGF2O1xufVxuXG5mdW5jdGlvbiBjb2hlcmUoKSB7XG4gIHJldHVybiBbMCwgMF07XG59XG5cbmZ1bmN0aW9uIGFsaWduKCkge1xuICByZXR1cm4gWzAsIDBdO1xufVxuXG5mdW5jdGlvbiBncmF2aXRhdGUoKSB7XG4gIHJldHVybiBbMCwgMF07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2pzL2JvaWRfc3RkLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vXG4vLyBTaW11bGF0aW9uIE1hdGggVXRpbGl0aWVzXG4vL1xuLy8gVE9ETyBGSVhcbi8vIFRPRE8gdGhpcyBpcyBqdXN0IHRocm93aW5nIGV2ZXJ5dGhpbmcgaW50byB0aGVcbi8vICAgICAgZ2xvYmFsIG5hbWVzcGFjZS4uLlxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICB0aGlzLm5lYXJseVplcm8gPSAwLjAwMDAxO1xuXG4gIHRoaXMubm9ybWFsaXplID0gZnVuY3Rpb24gKHYpIHtcbiAgICBsZXQgbHYgPSBNYXRoLnNxcnQodlswXSp2WzBdICsgdlsxXSp2WzFdKTtcbiAgICBpZiAoTWF0aC5hYnMobHYpID4gbmVhcmx5WmVybykge1xuICAgICAgdlswXSAvPSBsdjtcbiAgICAgIHZbMV0gLz0gbHY7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG5cbiAgdGhpcy5kb3QgPSBmdW5jdGlvbih2MSwgdjIpIHtcbiAgICByZXR1cm4gdjFbMF0qdjJbMF0gKyB2MVsxXSp2MlsxXVxuICB9XG5cbiAgdGhpcy5idWlsZFJvdGF0aW9uTWF0cml4ID0gZnVuY3Rpb24oZGVncmVlcykge1xuICAgIHZhciByYWRpYW5zID0gZGVncmVlcyAqIE1hdGguUEkgLyAxODAuMDtcbiAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgW01hdGguY29zKHJhZGlhbnMpLCAtTWF0aC5zaW4ocmFkaWFucyldLFxuICAgICAgW01hdGguc2luKHJhZGlhbnMpLCBNYXRoLmNvcyhyYWRpYW5zKV0sXG4gICAgXTtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG5cbiAgdGhpcy5yb3RhdGUgPSBmdW5jdGlvbih2LCBtKSB7XG4gICAgdmFyIHggPSBtWzBdWzBdKnZbMF0gKyBtWzBdWzFdKnZbMV1cbiAgICB2YXIgeSA9IG1bMV1bMF0qdlswXSArIG1bMV1bMV0qdlsxXVxuICAgIHJldHVybiBbeCwgeV07XG4gIH1cblxuICB0aGlzLnJhbmRvbUluUmFuZ2UgPSBmdW5jdGlvbihtaW4sIG1heCwgd2FudEludCkge1xuICAgIHZhciBtYXggPSAobWF4ID09PSAwIHx8IG1heCkgPyBtYXggOiAxLFxuICAgICAgICBtaW4gPSBtaW4gfHwgMCxcbiAgICAgICAgZ2VuID0gbWluICsgKG1heCAtIG1pbikgKiBNYXRoLnJhbmRvbSgpO1xuXG4gICAgcmV0dXJuICh3YW50SW50KSA/IE1hdGgucm91bmQoZ2VuKSA6IGdlbjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgZG90OiBkb3QsXG4gICAgYnVpbGRSb3RhdGlvbk1hdHJpeDogYnVpbGRSb3RhdGlvbk1hdHJpeCxcbiAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICByYW5kb21JblJhbmdlOiByYW5kb21JblJhbmdlXG4gIH07XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9qcy9zbXUub3JpZy5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9